# -*- generated by 1.0.11 -*-
import da
PatternExpr_684 = da.pat.TuplePattern([da.pat.ConstantPattern('wedge_client')])
PatternExpr_689 = da.pat.FreePattern('olympus')
PatternExpr_711 = da.pat.TuplePattern([da.pat.ConstantPattern('new-config'), da.pat.FreePattern('new_r'), da.pat.FreePattern('encrypt_hashresult'), da.pat.FreePattern('public_key_dict')])
PatternExpr_721 = da.pat.FreePattern('olympus')
PatternExpr_926 = da.pat.TuplePattern([da.pat.ConstantPattern('re-trans-replica'), da.pat.FreePattern('encrypt_hashresult'), da.pat.FreePattern('encrypt_res'), da.pat.FreePattern('rid')])
PatternExpr_936 = da.pat.FreePattern('replicas')
PatternExpr_1070 = da.pat.TuplePattern([da.pat.ConstantPattern('result'), da.pat.FreePattern('encrypt_hashresult'), da.pat.FreePattern('encrypt_res'), da.pat.FreePattern('rid')])
PatternExpr_1080 = da.pat.FreePattern('tail')
_config_object = {}
import sys
import nacl.encoding
import nacl.hash
import nacl.signing
from nacl.bindings.utils import sodium_memcmp
from re import split
import time
import logging

class CL(da.DistProcess):

    def __init__(self, procimpl, props):
        super().__init__(procimpl, props)
        self._events.extend([da.pat.EventPattern(da.pat.ReceivedEvent, '_CLReceivedEvent_0', PatternExpr_684, sources=[PatternExpr_689], destinations=None, timestamps=None, record_history=None, handlers=[self._CL_handler_683]), da.pat.EventPattern(da.pat.ReceivedEvent, '_CLReceivedEvent_1', PatternExpr_711, sources=[PatternExpr_721], destinations=None, timestamps=None, record_history=None, handlers=[self._CL_handler_710]), da.pat.EventPattern(da.pat.ReceivedEvent, '_CLReceivedEvent_2', PatternExpr_926, sources=[PatternExpr_936], destinations=None, timestamps=None, record_history=None, handlers=[self._CL_handler_925]), da.pat.EventPattern(da.pat.ReceivedEvent, '_CLReceivedEvent_3', PatternExpr_1070, sources=[PatternExpr_1080], destinations=None, timestamps=None, record_history=None, handlers=[self._CL_handler_1069])])

    def setup(self, workload, r, c, cid, public_key_dict, pk, client_timeout, parent, olympus, **rest_1296):
        super().setup(workload=workload, r=r, c=c, cid=cid, public_key_dict=public_key_dict, pk=pk, client_timeout=client_timeout, parent=parent, olympus=olympus, **rest_1296)
        self._state.workload = workload
        self._state.r = r
        self._state.c = c
        self._state.cid = cid
        self._state.public_key_dict = public_key_dict
        self._state.pk = pk
        self._state.client_timeout = client_timeout
        self._state.parent = parent
        self._state.olympus = olympus
        self._state.x = split('[;]+', self._state.workload)
        self._state.rep = self._state.r
        self._state.rec = 0
        self._state.pk = self._state.pk
        self._state.rid = (- 1)
        self._state.result = []
        self._state.timer_expired = False
        self._state.rid_seen = []
        self._state.min_match = (((len(self._state.r) - 1) / 2) + 1)
        self._state.send_wait = True
        self._state.encrypt_oper = ''
        self._state.encrypt_rid = ''
        self._state.prw = ["put('k1','kv1')", "append('k1',' kv2')", "slice('k1','0:2')", "get('k1')", "put('k2','v1')", "append('k2',' v2')", "slice('k2','0:1')", "get('k2')"]

    def run(self):
        logging.basicConfig(format='%(asctime)s : %(message)s', level=logging.INFO, filename=(sys.argv[(- 1)][0:(- 4)] + '_client_log.log'))
        if self._state.workload.startswith('pseudorandom'):
            self._state.x = []
            temp = split('[,()]+', self._state.workload)
            pr = [temp[1], temp[2]]
            for i in range(int(pr[1])):
                self._state.x.append(self._state.prw[((int(pr[0]) + i) % len(self._state.prw))])
            logging.info((('Client ' + str(self._state.c.index(self._state.cid))) + ' psuedorandom workload is generated'))
        for (i, y) in enumerate(self._state.x):
            self._state.x[i] = self._state.x[i].strip()
            self._state.rid = (self._state.rid + 1)
            self._state.rid_seen.append(0)
            self._state.encrypt_oper = self._state.pk.sign(self._state.x[i].encode())
            self._state.encrypt_rid = self._state.pk.sign(str(self._state.rid).encode())
            super()._label('_st_label_436', block=False)
            _st_label_436 = 0
            while (_st_label_436 == 0):
                _st_label_436 += 1
                if self._state.send_wait:
                    _st_label_436 += 1
                else:
                    super()._label('_st_label_436', block=True)
                    _st_label_436 -= 1
            else:
                if (_st_label_436 != 2):
                    continue
            if (_st_label_436 != 2):
                break
            logging.info((((((((('Client ' + str(self._state.c.index(self._state.cid))) + ': Client ') + str(self._state.c.index(self._state.cid))) + ' sent request number ') + str(self._state.rid)) + ' opration ') + self._state.x[i]) + ' to replica 0'))
            self.send(('parent-trans', self._state.encrypt_oper, self._state.encrypt_rid), to=self._state.parent)
            self.send(('initial_transmission', self._state.encrypt_oper, self._state.encrypt_rid), to=self._state.rep[0])
            prec = self._state.rec
            logging.info(((((('Client ' + str(self._state.c.index(self._state.cid))) + ': prec is ') + str(prec)) + ' rec is ') + str(self._state.rec)))
            super()._label('_st_label_518', block=False)
            _st_label_518 = 0
            self._timer_start()
            while (_st_label_518 == 0):
                _st_label_518 += 1
                if (self._state.rec == (prec + 1)):
                    logging.info(((((('Client ' + str(self._state.c.index(self._state.cid))) + ': Client ') + str(self._state.c.index(self._state.cid))) + ' result arrived  for rid ') + str(self._state.rid)))
                    _st_label_518 += 1
                elif self._timer_expired:
                    super()._label('_st_label_553', block=False)
                    _st_label_553 = 0
                    while (_st_label_553 == 0):
                        _st_label_553 += 1
                        if self._state.send_wait:
                            _st_label_553 += 1
                        else:
                            super()._label('_st_label_553', block=True)
                            _st_label_553 -= 1
                    else:
                        if (_st_label_553 != 2):
                            continue
                    if (_st_label_553 != 2):
                        break
                    logging.info(((((((('Client ' + str(self._state.c.index(self._state.cid))) + ': Client ') + str(self._state.c.index(self._state.cid))) + ' timer expired for  request number ') + str(self._state.rid)) + ' opration ') + self._state.x[i]))
                    self._state.timer_expired = True
                    self.send(('re-trans-client', self._state.encrypt_oper, self._state.encrypt_rid), to=self._state.rep)
                    self._state.timer_expired = False
                    logging.info((((((((('Client ' + str(self._state.c.index(self._state.cid))) + ':  Client ') + str(self._state.c.index(self._state.cid))) + ' sent  request number ') + str(self._state.rid)) + ' operation ') + self._state.x[i]) + ' to all replicas after timeout'))
                    super()._label('_st_label_637', block=False)
                    _st_label_637 = 0
                    while (_st_label_637 == 0):
                        _st_label_637 += 1
                        if (self._state.rec == (prec + 1)):
                            _st_label_637 += 1
                        else:
                            super()._label('_st_label_637', block=True)
                            _st_label_637 -= 1
                    else:
                        if (_st_label_637 != 2):
                            continue
                    if (_st_label_637 != 2):
                        break
                    _st_label_518 += 1
                else:
                    super()._label('_st_label_518', block=True, timeout=self._state.client_timeout)
                    _st_label_518 -= 1
            else:
                if (_st_label_518 != 2):
                    continue
            if (_st_label_518 != 2):
                break
        super()._label('_st_label_644', block=False)
        _st_label_644 = 0
        while (_st_label_644 == 0):
            _st_label_644 += 1
            if (self._state.rec == len(self._state.x)):
                _st_label_644 += 1
            else:
                super()._label('_st_label_644', block=True)
                _st_label_644 -= 1
        self.send(('finish', self._state.result), to=self._state.parent)
        logging.info((((('Client ' + str(self._state.c.index(self._state.cid))) + ':  Client ') + str(self._state.c.index(self._state.cid))) + ' sent fianl results to parent for checking'))
        super()._label('_st_label_679', block=False)
        _st_label_679 = 0
        while (_st_label_679 == 0):
            _st_label_679 += 1
            if False:
                _st_label_679 += 1
            else:
                super()._label('_st_label_679', block=True)
                _st_label_679 -= 1

    def _CL_handler_683(self, olympus):
        logging.info((('Client ' + str(self._state.c.index(self._state.cid))) + ': Client received wedged_client'))
        self._state.send_wait = False
    _CL_handler_683._labels = None
    _CL_handler_683._notlabels = None

    def _CL_handler_710(self, new_r, encrypt_hashresult, public_key_dict, olympus):
        logging.info((('Client ' + str(self._state.c.index(self._state.cid))) + ': Client received new config from olympus'))
        self._state.public_key_dict = public_key_dict
        match = 0
        self._state.rep = new_r
        self._state.send_wait = True
        if (len(encrypt_hashresult) > 0):
            for h in encrypt_hashresult:
                bres = nacl.encoding.HexEncoder.decode(h[1])
                orig_dgs = nacl.hash.sha256(bres, encoder=nacl.encoding.HexEncoder)
                if sodium_memcmp(h[0], orig_dgs):
                    encrypt_res = bres.decode()
                    self._state.rid = h[3]
                    if (bres.decode() == encrypt_res):
                        match = (match + 1)
            logging.info(((((((((('Client ' + str(self._state.c.index(self._state.cid))) + ' : match is ') + str(match)) + ' min match is ') + str(self._state.min_match)) + 'for rid ') + str(self._state.rid)) + ' rid seen ') + str(self._state.rid_seen)))
            if ((match >= self._state.min_match) and (self._state.rid_seen[self._state.rid] == 0)):
                self._state.rid_seen[self._state.rid] = 1
                match = 0
                logging.info((('Client ' + str(self._state.c.index(self._state.cid))) + ': Result validation success for new config after receiving re-transmit result from olympus'))
                self._state.result.append(encrypt_res)
                self._state.rec = (self._state.rec + 1)
            elif (match < self._state.min_match):
                self.send(('client-reconfig-request',), to=olympus)
                logging.info((('Client ' + str(self._state.c.index(self._state.cid))) + ': reconfig request sent to olympus'))
        else:
            self.send(('re-trans-client', self._state.encrypt_oper, self._state.encrypt_rid), to=self._state.rep)
    _CL_handler_710._labels = None
    _CL_handler_710._notlabels = None

    def _CL_handler_925(self, encrypt_hashresult, encrypt_res, rid, replicas):
        match = 0
        for h in encrypt_hashresult:
            bres = nacl.encoding.HexEncoder.decode(h[1])
            orig_dgs = nacl.hash.sha256(bres, encoder=nacl.encoding.HexEncoder)
            if sodium_memcmp(h[0], orig_dgs):
                if (bres.decode() == encrypt_res):
                    match = (match + 1)
        if ((match >= self._state.min_match) and (self._state.rid_seen[rid] == 0)):
            self._state.rid_seen[rid] = 1
            match = 0
            logging.info(((((('Client ' + str(self._state.c.index(self._state.cid))) + ': Result validation success after receiving re-transmit result from replica ') + str(self._state.r.index(replicas))) + ' for rid ') + str(rid)))
            self._state.result.append(encrypt_res)
            self._state.rec = (self._state.rec + 1)
        elif (match < self._state.min_match):
            self.send(('client-reconfig-request',), to=self._state.olympus)
            logging.info((('Client ' + str(self._state.c.index(self._state.cid))) + ': reconfig request sent to olympus'))
    _CL_handler_925._labels = None
    _CL_handler_925._notlabels = None

    def _CL_handler_1069(self, encrypt_hashresult, encrypt_res, rid, tail):
        if (not self._state.timer_expired):
            c_t_dkey = nacl.signing.VerifyKey(self._state.public_key_dict[tail], encoder=nacl.encoding.HexEncoder)
            try:
                c_t_dkey.verify(encrypt_hashresult)
                c_t_dkey.verify(encrypt_res)
                res = encrypt_res.message.decode()
                hashresult = eval(encrypt_hashresult.message.decode())
            except nacl.exceptions.BadSignatureError:
                logging.info((('Client ' + str(self._state.c.index(self._state.cid))) + ':  tail to client signature fail for rid +str(rid)'))
                self.send(('reconfig-request',), to=self._state.olympus)
            logging.info((('Client ' + str(self._state.c.index(self._state.cid))) + ':  tail to client signature success for rid +str(rid)'))
            match = 0
            for h in hashresult:
                bres = nacl.encoding.HexEncoder.decode(h[1])
                orig_dgs = nacl.hash.sha256(bres, encoder=nacl.encoding.HexEncoder)
                if sodium_memcmp(h[0], orig_dgs):
                    if (bres.decode() == res):
                        match = (match + 1)
            if (match >= self._state.min_match):
                if (self._state.rid_seen[rid] == 0):
                    self._state.rid_seen[rid] = 1
                    logging.info(((('Client ' + str(self._state.c.index(self._state.cid))) + ': Result validation success after receiving result from tail for rid ') + str(rid)))
                    self._state.result.append(res)
                    self._state.rec = (self._state.rec + 1)
            else:
                logging.error(((('Client ' + str(self._state.c.index(self._state.cid))) + ': Result validation failed after receiving result from tail for rid ') + str(rid)))
                self.send(('client-reconfig-request',), to=self._state.olympus)
                logging.info((('Client ' + str(self._state.c.index(self._state.cid))) + ': reconfig request sent to olympus'))
            match = 0
    _CL_handler_1069._labels = None
    _CL_handler_1069._notlabels = None
