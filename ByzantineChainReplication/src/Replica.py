# -*- generated by 1.0.11 -*-
import da
PatternExpr_559 = da.pat.TuplePattern([da.pat.ConstantPattern('wedged_req1')])
PatternExpr_564 = da.pat.FreePattern('olympus')
PatternExpr_584 = da.pat.TuplePattern([da.pat.ConstantPattern('wedged_req')])
PatternExpr_589 = da.pat.FreePattern('olympus')
PatternExpr_1131 = da.pat.TuplePattern([da.pat.ConstantPattern('get_running_state')])
PatternExpr_1136 = da.pat.FreePattern('olympus')
PatternExpr_1605 = da.pat.TuplePattern([da.pat.ConstantPattern('catch_up_req'), da.pat.FreePattern('catchup')])
PatternExpr_1612 = da.pat.FreePattern('olympus')
PatternExpr_2327 = da.pat.TuplePattern([da.pat.ConstantPattern('re-trans-client'), da.pat.FreePattern('encrypt_oper'), da.pat.FreePattern('encrypt_rid')])
PatternExpr_2336 = da.pat.FreePattern('client')
PatternExpr_3321 = da.pat.TuplePattern([da.pat.ConstantPattern('forward-req'), da.pat.FreePattern('encrypt_oper_rep'), da.pat.FreePattern('encrypt_oper'), da.pat.FreePattern('encrypt_rid'), da.pat.FreePattern('client')])
PatternExpr_3334 = da.pat.FreePattern('replica')
PatternExpr_4302 = da.pat.TuplePattern([da.pat.ConstantPattern('head-retrans-head'), da.pat.FreePattern('encrypt_oper_rep'), da.pat.FreePattern('encrypt_oper'), da.pat.FreePattern('encrypt_rid'), da.pat.FreePattern('client')])
PatternExpr_4315 = da.pat.FreePattern('head')
PatternExpr_4750 = da.pat.TuplePattern([da.pat.ConstantPattern('initial_transmission'), da.pat.FreePattern('encrypt_operation'), da.pat.FreePattern('encrypt_rid')])
PatternExpr_4759 = da.pat.FreePattern('client')
PatternExpr_6053 = da.pat.TuplePattern([da.pat.ConstantPattern('result-shuttle'), da.pat.FreePattern('encrypt_hashresult'), da.pat.FreePattern('client')])
PatternExpr_6062 = da.pat.FreePattern('frep')
PatternExpr_6786 = da.pat.TuplePattern([da.pat.ConstantPattern('forward_chekpoint_proof'), da.pat.FreePattern('encrypt_checkpoint_proof')])
PatternExpr_6793 = da.pat.FreePattern('prev_rep')
PatternExpr_7629 = da.pat.TuplePattern([da.pat.ConstantPattern('reverse_chekpoint_proof'), da.pat.FreePattern('encrypt_checkpoint_proof')])
PatternExpr_7636 = da.pat.FreePattern('frep')
PatternExpr_8461 = da.pat.TuplePattern([da.pat.ConstantPattern('rep_trans'), da.pat.FreePattern('encrypt_slot'), da.pat.FreePattern('encrypt_operation_rep'), da.pat.FreePattern('encrypt_operation'), da.pat.FreePattern('encrypt_order_proof'), da.pat.FreePattern('encrypt_hashresult'), da.pat.FreePattern('client'), da.pat.FreePattern('rid_slot'), da.pat.FreePattern('rid')])
PatternExpr_8481 = da.pat.FreePattern('prev_rep')
PatternExpr_9959 = da.pat.TuplePattern([da.pat.ConstantPattern('kill')])
PatternExpr_9964 = da.pat.FreePattern('olympus')
PatternExpr_9992 = da.pat.TuplePattern([da.pat.ConstantPattern('active')])
PatternExpr_9997 = da.pat.FreePattern('olympus')
_config_object = {}
import sys
import nacl.encoding
import nacl.hash
import nacl.signing
from nacl.bindings.utils import sodium_memcmp
from re import split
import time
import logging
import os

class replica(da.DistProcess):

    def __init__(self, procimpl, props):
        super().__init__(procimpl, props)
        self._events.extend([da.pat.EventPattern(da.pat.ReceivedEvent, '_replicaReceivedEvent_0', PatternExpr_559, sources=[PatternExpr_564], destinations=None, timestamps=None, record_history=None, handlers=[self._replica_handler_558]), da.pat.EventPattern(da.pat.ReceivedEvent, '_replicaReceivedEvent_1', PatternExpr_584, sources=[PatternExpr_589], destinations=None, timestamps=None, record_history=None, handlers=[self._replica_handler_583]), da.pat.EventPattern(da.pat.ReceivedEvent, '_replicaReceivedEvent_2', PatternExpr_1131, sources=[PatternExpr_1136], destinations=None, timestamps=None, record_history=None, handlers=[self._replica_handler_1130]), da.pat.EventPattern(da.pat.ReceivedEvent, '_replicaReceivedEvent_3', PatternExpr_1605, sources=[PatternExpr_1612], destinations=None, timestamps=None, record_history=None, handlers=[self._replica_handler_1604]), da.pat.EventPattern(da.pat.ReceivedEvent, '_replicaReceivedEvent_4', PatternExpr_2327, sources=[PatternExpr_2336], destinations=None, timestamps=None, record_history=None, handlers=[self._replica_handler_2326]), da.pat.EventPattern(da.pat.ReceivedEvent, '_replicaReceivedEvent_5', PatternExpr_3321, sources=[PatternExpr_3334], destinations=None, timestamps=None, record_history=None, handlers=[self._replica_handler_3320]), da.pat.EventPattern(da.pat.ReceivedEvent, '_replicaReceivedEvent_6', PatternExpr_4302, sources=[PatternExpr_4315], destinations=None, timestamps=None, record_history=None, handlers=[self._replica_handler_4301]), da.pat.EventPattern(da.pat.ReceivedEvent, '_replicaReceivedEvent_7', PatternExpr_4750, sources=[PatternExpr_4759], destinations=None, timestamps=None, record_history=None, handlers=[self._replica_handler_4749]), da.pat.EventPattern(da.pat.ReceivedEvent, '_replicaReceivedEvent_8', PatternExpr_6053, sources=[PatternExpr_6062], destinations=None, timestamps=None, record_history=None, handlers=[self._replica_handler_6052]), da.pat.EventPattern(da.pat.ReceivedEvent, '_replicaReceivedEvent_9', PatternExpr_6786, sources=[PatternExpr_6793], destinations=None, timestamps=None, record_history=None, handlers=[self._replica_handler_6785]), da.pat.EventPattern(da.pat.ReceivedEvent, '_replicaReceivedEvent_10', PatternExpr_7629, sources=[PatternExpr_7636], destinations=None, timestamps=None, record_history=None, handlers=[self._replica_handler_7628]), da.pat.EventPattern(da.pat.ReceivedEvent, '_replicaReceivedEvent_11', PatternExpr_8461, sources=[PatternExpr_8481], destinations=None, timestamps=None, record_history=None, handlers=[self._replica_handler_8460]), da.pat.EventPattern(da.pat.ReceivedEvent, '_replicaReceivedEvent_12', PatternExpr_9959, sources=[PatternExpr_9964], destinations=None, timestamps=None, record_history=None, handlers=[self._replica_handler_9958]), da.pat.EventPattern(da.pat.ReceivedEvent, '_replicaReceivedEvent_13', PatternExpr_9992, sources=[PatternExpr_9997], destinations=None, timestamps=None, record_history=None, handlers=[self._replica_handler_9991])])

    def setup(self, a, d, history, slot, r, idr, c, public_key_dict, pk, replica_timeout, head_timeout, failure, olympus, configuration, checkpoint, **rest_10429):
        super().setup(a=a, d=d, history=history, slot=slot, r=r, idr=idr, c=c, public_key_dict=public_key_dict, pk=pk, replica_timeout=replica_timeout, head_timeout=head_timeout, failure=failure, olympus=olympus, configuration=configuration, checkpoint=checkpoint, **rest_10429)
        self._state.a = a
        self._state.d = d
        self._state.history = history
        self._state.slot = slot
        self._state.r = r
        self._state.idr = idr
        self._state.c = c
        self._state.public_key_dict = public_key_dict
        self._state.pk = pk
        self._state.replica_timeout = replica_timeout
        self._state.head_timeout = head_timeout
        self._state.failure = failure
        self._state.olympus = olympus
        self._state.configuration = configuration
        self._state.checkpoint = checkpoint
        self._state.s = 0
        self._state.terminate = self._state.a
        self._state.d = self._state.d
        self._state.temp_d = dict()
        self._state.res = ''
        self._state.result = dict()
        self._state.pk = self._state.pk
        self._state.public_key_dict = self._state.public_key_dict
        self._state.hr = dict()
        self._state.slot = self._state.slot
        self._state.history = self._state.history
        self._state.orderproof = []
        self._state.hashresult = []
        self._state.checkpoint_proof = []
        self._state.wedged_history = dict()
        self._state.rid_slot = dict()
        self._state.idr = self._state.idr
        self._state.fail = []
        self._state.ncr = dict()
        self._state.nfr = dict()
        self._state.ns = dict()
        self._state.nrs = dict()
        self._state.cr = 0
        self._state.co = 0
        self._state.drs = 0
        self._state.drop = 0
        self._state.crash = 0
        self._state.truncate_history = 0
        self._state.truncate_history_n = 0
        self._state.sleep = 0
        self._state.increment_slot = 0
        self._state.extra_op = 0
        self._state.invalid_order_sig = 0
        self._state.invalid_result_sig = 0
        self._state.drop_checkpt_stmts = 0
        self._state.checkpoint = self._state.checkpoint
        self._state.state = 0
        self._state.pslot = 0
        self._state.cresult = dict()
        self._state.slot_client = dict()
        self._state.nwr = (- 1)
        self._state.ncm = (- 1)
        self._state.nch = (- 1)
        self._state.ncom_ch = (- 1)
        self._state.ngrs = (- 1)
        self._state.ncatchup = (- 1)
        self._state.idr = self._state.idr
        self._state.kill = False
        if ((str(self._state.r.index(self._state.idr)) in self._state.failure.keys()) and (len(self._state.fail) == 0)):
            self.output(str(self._state.failure))
            for x in self._state.failure[str(self._state.r.index(self._state.idr))]:
                self._state.fail.append(split('[(,)]+', x))

    def run(self):
        logging.basicConfig(format='%(asctime)s : %(message)s', level=logging.INFO, filename=(sys.argv[(- 1)][0:(- 4)] + '_replica_log.log'))
        super()._label('_st_label_10427', block=False)
        _st_label_10427 = 0
        while (_st_label_10427 == 0):
            _st_label_10427 += 1
            if self._state.kill:
                _st_label_10427 += 1
            else:
                super()._label('_st_label_10427', block=True)
                _st_label_10427 -= 1

    def _replica_handler_558(self, olympus):
        h = self._state.wedged_history
        h.update(self._state.history)
        self.send(('wedged_statement1', h), to=olympus)
    _replica_handler_558._labels = None
    _replica_handler_558._notlabels = None

    def _replica_handler_583(self, olympus):
        if (self._state.state == 1):
            logging.info((((('Configuration ' + str(self._state.configuration)) + ' Replica ') + str(self._state.r.index(self._state.idr))) + ' : wedged req received from olympus'))
            self._state.nwr = (self._state.nwr + 1)
            for x in self._state.fail:
                if (x[0].strip() == 'wedge_request'):
                    if (int(x[1]) == self._state.nwr):
                        logging.info(((((((('Configuration ' + str(self._state.configuration)) + ' Replica ') + str(self._state.r.index(self._state.idr))) + ' : wedged req failure triggered for ') + str(self._state.nwr)) + ' msg ') + str(x[2])))
                        if (x[2].strip() == 'change_operation'):
                            self._state.co = 1
                        if (x[2].strip() == 'change_result'):
                            self._state.cr = 1
                        if (x[2].strip() == 'drop_result_stmt'):
                            self._state.drs = 1
                        if (x[2].strip() == 'drop'):
                            self._state.drop = 1
                        if (x[2].strip() == 'truncate_history'):
                            self._state.truncate_history = 1
                            self._state.truncate_history_n = int(x[3])
                        if (x[2].strip() == 'crash'):
                            self._state.crash = 1
                            logging.info((((('Configuration ' + str(self._state.configuration)) + ' Replica ') + str(self._state.r.index(self._state.idr))) + ' : implementing crash failure now..replica exiting..'))
                            self._state.crash = 0
                            logging.shutdown()
                            os._exit((- 1))
                        if (x[2].strip() == 'sleep'):
                            self._state.sleep = 1
                            logging.info((((('Configuration ' + str(self._state.configuration)) + ' Replica ') + str(self._state.r.index(self._state.idr))) + ' sleeping'))
                            time.sleep((int(x[3]) / 1000))
                            logging.info((((('Configuration ' + str(self._state.configuration)) + ' Replica ') + str(self._state.r.index(self._state.idr))) + ' woke up '))
                            self._state.sleep = 0
                        if (x[2].strip() == 'increment_slot'):
                            self._state.increment_slot = 1
                            if (self._state.r.index(self._state.idr) == 0):
                                self._state.slot = (self._state.slot + 1)
                            logging.info(((((((('Configuration ' + str(self._state.configuration)) + ' Replica ') + str(self._state.r.index(self._state.idr))) + ' slot number incremented from ') + str((self._state.slot - 1))) + ' to ') + str(self._state.slot)))
                            self._state.increment_slot = 0
                        if (x[2].strip() == 'extra_op'):
                            self._state.extra_op = 1
                            logging.info((((('Configuration ' + str(self._state.configuration)) + ' Replica ') + str(self._state.r.index(self._state.idr))) + ' put(a,a) performed and applied to running state'))
                            self._state.d['a'] = 'a'
                            self._state.extra_op = 0
                        if (x[2].strip() == 'invalid_order_sig'):
                            self._state.invalid_order_sig = 1
                        if (x[2].strip() == 'invalid_result_sig'):
                            self._state.invalid_result_sig = 1
                        if (x[2].strip() == 'drop_checkpt_stmts'):
                            self._state.drop_checkpt_stmts = 1
            if (self._state.drop == 1):
                logging.info((((('Configuration ' + str(self._state.configuration)) + ' Replica ') + str(self._state.r.index(self._state.idr))) + ' : drop (ignoring) the incoing msg'))
                self._state.drop = 0
                return
            self._state.state = 0
            logging.info((((('Configuration ' + str(self._state.configuration)) + ' Replica ') + str(self._state.r.index(self._state.idr))) + ' : state changed to immutable'))
            h = self._state.wedged_history
            h.update(self._state.history)
            if (self._state.truncate_history == 1):
                self._state.truncate_history = 0
                logging.info(((((('Configuration ' + str(self._state.configuration)) + ' Replica ') + str(self._state.r.index(self._state.idr))) + ' : Truncating the history by : ') + str(self._state.truncate_history_n)))
                keys = []
                for x in h:
                    keys.append(x)
                keys = sorted(keys)
                keys = keys[:(len(keys) - self._state.truncate_history_n)]
                for x in keys:
                    h.pop(x)
            self.send(('wedged_statement', h), to=olympus)
            logging.info((((('Configuration ' + str(self._state.configuration)) + ' Replica ') + str(self._state.r.index(self._state.idr))) + ' : wedged statement sent to olympus'))
        else:
            pass
    _replica_handler_583._labels = None
    _replica_handler_583._notlabels = None

    def _replica_handler_1130(self, olympus):
        logging.info((((('Configuration ' + str(self._state.configuration)) + ' Replica ') + str(self._state.r.index(self._state.idr))) + ' : Get running state msg received from olympus'))
        self._state.ngrs = (self._state.ngrs + 1)
        for x in self._state.fail:
            if (x[0].strip() == 'get_running_state'):
                if (int(x[1]) == self._state.ngrs):
                    logging.info(((((((('Configuration ' + str(self._state.configuration)) + ' Replica ') + str(self._state.r.index(self._state.idr))) + ' : get_running_state failure triggered for ') + str(self._state.ngrs)) + ' msg ') + str(x[2])))
                    if (x[2].strip() == 'change_operation'):
                        self._state.co = 1
                    if (x[2].strip() == 'change_result'):
                        self._state.cr = 1
                    if (x[2].strip() == 'drop_result_stmt'):
                        self._state.drs = 1
                    if (x[2].strip() == 'drop'):
                        self._state.drop = 1
                    if (x[2].strip() == 'crash'):
                        self._state.crash = 1
                        logging.info((((('Configuration ' + str(self._state.configuration)) + ' Replica ') + str(self._state.r.index(self._state.idr))) + ' : implementing crash failure now..replica exiting..'))
                        self._state.crash = 0
                        logging.shutdown()
                        os._exit((- 1))
                    if (x[2].strip() == 'truncate_history'):
                        self._state.truncate_history = 1
                        self._state.truncate_history_n = int(x[3])
                    if (x[2].strip() == 'sleep'):
                        self._state.sleep = 1
                        logging.info((((('Configuration ' + str(self._state.configuration)) + ' Replica ') + str(self._state.r.index(self._state.idr))) + ' sleeping'))
                        time.sleep((int(x[3]) / 1000))
                        logging.info((((('Configuration ' + str(self._state.configuration)) + ' Replica ') + str(self._state.r.index(self._state.idr))) + ' woke up '))
                        self._state.sleep = 0
                    if (x[2].strip() == 'increment_slot'):
                        self._state.increment_slot = 1
                        if (self._state.r.index(self._state.idr) == 0):
                            self._state.slot = (self._state.slot + 1)
                        logging.info(((((((('Configuration ' + str(self._state.configuration)) + ' Replica ') + str(self._state.r.index(self._state.idr))) + ' slot number incremented from ') + str((self._state.slot - 1))) + ' to ') + str(self._state.slot)))
                        self._state.increment_slot = 0
                    if (x[2].strip() == 'extra_op'):
                        self._state.extra_op = 1
                        logging.info((((('Configuration ' + str(self._state.configuration)) + ' Replica ') + str(self._state.r.index(self._state.idr))) + ' put(a,a) performed and applied to running state'))
                        self._state.d['a'] = 'a'
                        self._state.extra_op = 0
                    if (x[2].strip() == 'invalid_order_sig'):
                        self._state.invalid_order_sig = 1
                    if (x[2].strip() == 'invalid_result_sig'):
                        self._state.invalid_result_sig = 1
                    if (x[2].strip() == 'drop_checkpt_stmts'):
                        self._state.drop_checkpt_stmts = 1
        if (self._state.drop == 1):
            logging.info((((('Configuration ' + str(self._state.configuration)) + ' Replica ') + str(self._state.r.index(self._state.idr))) + ' : drop (ignoring) the incoing msg'))
            self._state.drop = 0
            return
        en_data_dict = repr(self._state.d).encode()
        data_dict_digest = nacl.hash.sha256(en_data_dict, encoder=nacl.encoding.HexEncoder)
        data_dict_hash = nacl.encoding.HexEncoder.encode(en_data_dict)
        self.send(('get_running_state_res', data_dict_digest, data_dict_hash, self._state.cresult), to=olympus)
        logging.info((((('Configuration ' + str(self._state.configuration)) + ' Replica ') + str(self._state.r.index(self._state.idr))) + ' : sent running state msg to olympus'))
    _replica_handler_1130._labels = None
    _replica_handler_1130._notlabels = None

    def _replica_handler_1604(self, catchup, olympus):
        logging.info((((('Configuration ' + str(self._state.configuration)) + ' Replica ') + str(self._state.r.index(self._state.idr))) + ' : catch up msg received from olympus'))
        self._state.ncatchup = (self._state.ncatchup + 1)
        for x in self._state.fail:
            if (x[0].strip() == 'catch_up'):
                if (int(x[1]) == self._state.ncatchup):
                    logging.info(((((((('Configuration ' + str(self._state.configuration)) + ' Replica ') + str(self._state.r.index(self._state.idr))) + ' : catch_up failure triggered for ') + str(self._state.ncatchup)) + ' msg ') + str(x[2])))
                    if (x[2].strip() == 'change_operation'):
                        self._state.co = 1
                    if (x[2].strip() == 'change_result'):
                        self._state.cr = 1
                    if (x[2].strip() == 'drop_result_stmt'):
                        self._state.drs = 1
                    if (x[2].strip() == 'drop'):
                        self._state.drop = 1
                    if (x[2].strip() == 'crash'):
                        self._state.crash = 1
                        logging.info((((('Configuration ' + str(self._state.configuration)) + ' Replica ') + str(self._state.r.index(self._state.idr))) + ' : implementing crash failure now..replica exiting..'))
                        self._state.crash = 0
                        logging.shutdown()
                        os._exit((- 1))
                    if (x[2].strip() == 'truncate_history'):
                        self._state.truncate_history = 1
                        self._state.truncate_history_n = int(x[3])
                    if (x[2].strip() == 'sleep'):
                        self._state.sleep = 1
                        logging.info((((('Configuration ' + str(self._state.configuration)) + ' Replica ') + str(self._state.r.index(self._state.idr))) + ' sleeping'))
                        time.sleep((int(x[3]) / 1000))
                        logging.info((((('Configuration ' + str(self._state.configuration)) + ' Replica ') + str(self._state.r.index(self._state.idr))) + ' woke up '))
                        self._state.sleep = 0
                    if (x[2].strip() == 'increment_slot'):
                        self._state.increment_slot = 1
                        if (self._state.r.index(self._state.idr) == 0):
                            self._state.slot = (self._state.slot + 1)
                        logging.info(((((((('Configuration ' + str(self._state.configuration)) + ' Replica ') + str(self._state.r.index(self._state.idr))) + ' slot number incremented from ') + str((self._state.slot - 1))) + ' to ') + str(self._state.slot)))
                        self._state.increment_slot = 0
                    if (x[2].strip() == 'extra_op'):
                        self._state.extra_op = 1
                        logging.info((((('Configuration ' + str(self._state.configuration)) + ' Replica ') + str(self._state.r.index(self._state.idr))) + ' put(a,a) performed and applied to running state'))
                        self._state.d['a'] = 'a'
                        self._state.extra_op = 0
                    if (x[2].strip() == 'invalid_order_sig'):
                        self._state.invalid_order_sig = 1
                    if (x[2].strip() == 'invalid_result_sig'):
                        self._state.invalid_result_sig = 1
                    if (x[2].strip() == 'drop_checkpt_stmts'):
                        self._state.drop_checkpt_stmts = 1
        if (self._state.drop == 1):
            logging.info((((('Configuration ' + str(self._state.configuration)) + ' Replica ') + str(self._state.r.index(self._state.idr))) + ' : drop (ignoring) the incoing msg'))
            self._state.drop = 0
            return
        self.output(catchup)
        d1 = self._state.d
        for op in catchup:
            logging.info(((((('Configuration ' + str(self._state.configuration)) + ' Replica ') + str(self._state.r.index(self._state.idr))) + '  replica previous history ') + str(self._state.history)))
            self._state.history[op] = catchup[op]
            logging.info(((((('Configuration ' + str(self._state.configuration)) + ' Replica ') + str(self._state.r.index(self._state.idr))) + '  replica updated history ') + str(self._state.history)))
            operation = catchup[op][0]
            x = split("[,()']+", operation)
            if (x[0] == 'put'):
                self._state.d[x[1]] = x[2]
                self._state.res = 'ok'
            if (x[0] == 'get'):
                try:
                    self._state.res = self._state.d[x[1]]
                except KeyError:
                    self._state.res = ''
            if (x[0] == 'append'):
                try:
                    self._state.d[x[1]] = (self._state.d[x[1]] + x[2])
                    self._state.res = 'update ok'
                except KeyError:
                    self._state.res = 'update failed'
            if (x[0] == 'slice'):
                x[2] = x[2].split(':')
                try:
                    self._state.d[x[1]] = self._state.d[x[1]][int(x[2][0]):int(x[2][1])]
                    self._state.res = 'slice ok'
                except KeyError:
                    self._state.res = 'slice fail'
            en_res = self._state.res.encode()
            res_digest = nacl.hash.sha256(en_res, encoder=nacl.encoding.HexEncoder)
            res_hash = nacl.encoding.HexEncoder.encode(en_res)
            self._state.cresult[catchup[op][1]] = [res_digest, res_hash, op, catchup[op][2]]
        en_data_dict = repr(self._state.d).encode()
        data_dict_digest = nacl.hash.sha256(en_data_dict, encoder=nacl.encoding.HexEncoder)
        data_dict_hash = nacl.encoding.HexEncoder.encode(en_data_dict)
        logging.info(((((('Configuration ' + str(self._state.configuration)) + ' Replica ') + str(self._state.r.index(self._state.idr))) + ' : sent caught_up_res to olympus ') + str(self._state.cresult)))
        self.send(('caught_up_res', data_dict_digest, data_dict_hash, self._state.cresult), to=olympus)
    _replica_handler_1604._labels = None
    _replica_handler_1604._notlabels = None

    def _replica_handler_2326(self, encrypt_oper, encrypt_rid, client):
        if (self._state.state == 1):
            client_rep_dkey = nacl.signing.VerifyKey(self._state.public_key_dict[client], encoder=nacl.encoding.HexEncoder)
            try:
                client_rep_dkey.verify(encrypt_oper)
                client_rep_dkey.verify(encrypt_rid)
                operation = encrypt_oper.message.decode()
                rid = int(encrypt_rid.message.decode())
            except nacl.exceptions.BadSignatureError:
                logging.error(((((((('Replica ' + str(self._state.r.index(self._state.idr))) + ' : Client ') + str(self._state.c.index(client))) + ' -> Replica ') + str(self._state.r.index(self._state.idr))) + ' re-transmission signature failed for rid ') + str(rid)))
            logging.info(((((((((('Configuration ' + str(self._state.configuration)) + ' Replica ') + str(self._state.r.index(self._state.idr))) + ' : Client ') + str(self._state.c.index(client))) + ' -> Replica ') + str(self._state.r.index(self._state.idr))) + ' re-transmission signature success for rid ') + str(rid)))
            logging.info(((((((((('Configuration ' + str(self._state.configuration)) + ' Replica ') + str(self._state.r.index(self._state.idr))) + ' : Client ') + str(self._state.c.index(client))) + ' -> Replica ') + str(self._state.r.index(self._state.idr))) + ' re-transmission msg received for rid ') + str(rid)))
            try:
                self._state.ncr[self._state.c.index(client)] = (self._state.ncr[self._state.c.index(client)] + 1)
            except KeyError:
                self._state.ncr[self._state.c.index(client)] = 0
            if (self._state.r.index(self._state.idr) == 5):
                logging.info(((('ncr is ' + str(self._state.ncr)) + ' fail is ') + str(self._state.fail)))
            for x in self._state.fail:
                if (x[0].strip() == 'client_request'):
                    if (int(x[1]) in self._state.ncr.keys()):
                        if ((self._state.ncr[int(x[1])] == int(x[2])) and (int(x[1]) == self._state.c.index(client))):
                            logging.info(((((((((('Configuration ' + str(self._state.configuration)) + ' Replica ') + str(self._state.r.index(self._state.idr))) + ' Client_request failure triggered at replica ') + str(self._state.r.index(self._state.idr))) + '  for client ') + x[1]) + ' message ') + x[2]))
                            if (x[3].strip() == 'change_operation'):
                                self._state.co = 1
                            if (x[3].strip() == 'change_result'):
                                self._state.cr = 1
                            if (x[3].strip() == 'drop_result_stmt'):
                                self._state.drs = 1
                            if (x[3].strip() == 'drop'):
                                self._state.drop = 1
                            if (x[3].strip() == 'truncate_history'):
                                self._state.truncate_history = 1
                                self._state.truncate_history_n = int(x[4])
                            if (x[3].strip() == 'crash'):
                                self._state.crash = 1
                                logging.info((((('Configuration ' + str(self._state.configuration)) + ' Replica ') + str(self._state.r.index(self._state.idr))) + ' : implementing crash failure now..replica exiting..'))
                                self._state.crash = 0
                                logging.shutdown()
                                os._exit((- 1))
                            if (x[3].strip() == 'sleep'):
                                self._state.sleep = 1
                                logging.info((((('Configuration ' + str(self._state.configuration)) + ' Replica ') + str(self._state.r.index(self._state.idr))) + ' sleeping'))
                                time.sleep((int(x[4]) / 1000))
                                logging.info((((('Configuration ' + str(self._state.configuration)) + ' Replica ') + str(self._state.r.index(self._state.idr))) + ' woke up '))
                                self._state.sleep = 0
                            if (x[3].strip() == 'increment_slot'):
                                self._state.increment_slot = 1
                                if (self._state.r.index(self._state.idr) == 0):
                                    self._state.slot = (self._state.slot + 1)
                                logging.info(((((((('Configuration ' + str(self._state.configuration)) + ' Replica ') + str(self._state.r.index(self._state.idr))) + ' slot number incremented from ') + str((self._state.slot - 1))) + ' to ') + str(self._state.slot)))
                                self._state.increment_slot = 0
                            if (x[3].strip() == 'extra_op'):
                                self._state.extra_op = 1
                                logging.info((((('Configuration ' + str(self._state.configuration)) + ' Replica ') + str(self._state.r.index(self._state.idr))) + ' put(a,a) performed and applied to running state'))
                                self._state.d['a'] = 'a'
                                self._state.extra_op = 0
                            if (x[3].strip() == 'invalid_order_sig'):
                                self._state.invalid_order_sig = 1
                            if (x[3].strip() == 'invalid_result_sig'):
                                self._state.invalid_result_sig = 1
                            if (x[3].strip() == 'drop_checkpt_stmts'):
                                self._state.drop_checkpt_stmts = 1
            if (self._state.drop == 1):
                logging.info((((('Configuration ' + str(self._state.configuration)) + ' Replica ') + str(self._state.r.index(self._state.idr))) + ' : drop (ignoring) the incoing msg'))
                self._state.drop = 0
                return
            if (((rid, client) in self._state.rid_slot.keys()) and (self._state.rid_slot[(rid, client)] in self._state.history.keys())):
                if (self._state.rid_slot[(rid, client)] in self._state.hr.keys()):
                    if (self._state.state == 1):
                        self.send(('re-trans-replica', self._state.hr[self._state.rid_slot[(rid, client)]], self._state.result[self._state.rid_slot[(rid, client)]], rid), to=client)
                        logging.info(((((((((('Configuration ' + str(self._state.configuration)) + ' Replica ') + str(self._state.r.index(self._state.idr))) + ' : Replica ') + str(self._state.r.index(self._state.idr))) + ' -> Client ') + str(self._state.c.index(client))) + ' cached result sent to client for rid ') + str(rid)))
            else:
                logging.info((((('Configuration ' + str(self._state.configuration)) + ' Replica ') + str(self._state.r.index(self._state.idr))) + ' : else condition enter'))
                if (not (self._state.r.index(self._state.idr) == 0)):
                    encrypt_oper_rep = self._state.pk.sign(operation.encode())
                    encrypt_rid = self._state.pk.sign(str(rid).encode())
                    logging.info((((('Configuration ' + str(self._state.configuration)) + ' Replica ') + str(self._state.r.index(self._state.idr))) + ' : before sending to head'))
                    self.send(('forward-req', encrypt_oper_rep, encrypt_oper, encrypt_rid, client), to=self._state.r[0])
                    logging.info(((((((((('Configuration ' + str(self._state.configuration)) + ' Replica ') + str(self._state.r.index(self._state.idr))) + ' : Replica ') + str(self._state.r.index(self._state.idr))) + ' ->Replica 0 forward request sent for client ') + str(self._state.c.index(client))) + ' rid ') + str(rid)))
                    super()._label('_st_label_3186', block=False)
                    _st_label_3186 = 0
                    self._timer_start()
                    while (_st_label_3186 == 0):
                        _st_label_3186 += 1
                        if (((rid, client) in self._state.rid_slot.keys()) and (self._state.rid_slot[(rid, client)] in self._state.hr.keys())):
                            self.send(('re-trans-replica', self._state.hr[self._state.rid_slot[(rid, client)]], self._state.result[self._state.rid_slot[(rid, client)]]), to=client)
                            logging.info(((((((((('Configuration ' + str(self._state.configuration)) + ' Replica ') + str(self._state.r.index(self._state.idr))) + ' : Replica ') + str(self._state.r.index(self._state.idr))) + ' -> Client ') + str(self._state.c.index(client))) + ' cached result arrived before timeout and sent to client for rid ') + str(rid)))
                            _st_label_3186 += 1
                        elif self._timer_expired:
                            if (self._state.state == 1):
                                logging.info(((((((((('Configuration ' + str(self._state.configuration)) + ' Replica ') + str(self._state.r.index(self._state.idr))) + ' : Replica ') + str(self._state.r.index(self._state.idr))) + ' -> Olympus proof of misbehaviour : cached result time out for client ') + str(self._state.c.index(client))) + ' rid ') + str(rid)))
                                self.send(('reconfig-request',), to=self._state.olympus)
                            _st_label_3186 += 1
                        else:
                            super()._label('_st_label_3186', block=True, timeout=self._state.replica_timeout)
                            _st_label_3186 -= 1
        else:
            pass
    _replica_handler_2326._labels = None
    _replica_handler_2326._notlabels = None

    def _replica_handler_3320(self, encrypt_oper_rep, encrypt_oper, encrypt_rid, client, replica):
        if (self._state.state == 1):
            rep_head_dkey = nacl.signing.VerifyKey(self._state.public_key_dict[replica], encoder=nacl.encoding.HexEncoder)
            rep_c_dkey = nacl.signing.VerifyKey(self._state.public_key_dict[client], encoder=nacl.encoding.HexEncoder)
            try:
                rep_head_dkey.verify(encrypt_oper_rep)
                rep_c_dkey.verify(encrypt_oper)
                rep_head_dkey.verify(encrypt_rid)
                operation = encrypt_oper_rep.message.decode()
                operation_client = encrypt_oper.message.decode()
                rid = int(encrypt_rid.message.decode())
            except nacl.exceptions.BadSignatureError:
                logging.error(((('Replica 0 : Replica ' + str(self._state.r.index(replica))) + ' -> Replica 0 forward-req signature failed for rid ') + str(rid)))
            logging.info(((((('Configuration ' + str(self._state.configuration)) + ' Replica 0 : Replica ') + str(self._state.r.index(replica))) + ' -> Replica 0 forward-req signature success for rid ') + str(rid)))
            logging.info(((((((('Configuration ' + str(self._state.configuration)) + ' Replica 0 received forwarded request from ') + str(self._state.r.index(replica))) + ' by client ') + str(self._state.c.index(client))) + ' rid ') + str(rid)))
            try:
                self._state.nfr[self._state.c.index(client)] = (self._state.nfr[self._state.c.index(client)] + 1)
            except KeyError:
                self._state.nfr[self._state.c.index(client)] = 0
            for x in self._state.fail:
                if (x[0].strip() == 'forwarded_request'):
                    if (int(x[1]) in self._state.nfr.keys()):
                        if ((self._state.nfr[int(x[1])] == int(x[2])) and (int(x[1]) == self._state.c.index(client))):
                            logging.info(((((((('Configuration ' + str(self._state.configuration)) + ' Replica 0: Forward_request failure triggered at replica ') + str(self._state.r.index(self._state.idr))) + '  for client ') + x[1]) + ' message ') + x[2]))
                            if (x[3].strip() == 'change_operation'):
                                self._state.co = 1
                            if (x[3].strip() == 'change_result'):
                                self._state.cr = 1
                            if (x[3].strip() == 'drop_result_stmt'):
                                self._state.drs = 1
                            if (x[3].strip() == 'drop'):
                                self._state.drop = 1
                            if (x[3].strip() == 'truncate_history'):
                                self._state.truncate_history = 1
                                self._state.truncate_history_n = int(x[4])
                            if (x[3].strip() == 'crash'):
                                self._state.crash = 1
                                logging.info((((('Configuration ' + str(self._state.configuration)) + ' Replica ') + str(self._state.r.index(self._state.idr))) + ' : implementing crash failure now..replica exiting..'))
                                self._state.crash = 0
                                logging.shutdown()
                                os._exit((- 1))
                            if (x[3].strip() == 'sleep'):
                                self._state.sleep = 1
                                logging.info((((('Configuration ' + str(self._state.configuration)) + ' Replica ') + str(self._state.r.index(self._state.idr))) + ' sleeping'))
                                time.sleep((int(x[4]) / 1000))
                                logging.info((((('Configuration ' + str(self._state.configuration)) + ' Replica ') + str(self._state.r.index(self._state.idr))) + ' woke up '))
                                self._state.sleep = 0
                            if (x[3].strip() == 'increment_slot'):
                                self._state.increment_slot = 1
                                if (self._state.r.index(self._state.idr) == 0):
                                    self._state.slot = (self._state.slot + 1)
                                logging.info(((((((('Configuration ' + str(self._state.configuration)) + ' Replica ') + str(self._state.r.index(self._state.idr))) + ' slot number incremented from ') + str((self._state.slot - 1))) + ' to ') + str(self._state.slot)))
                                self._state.increment_slot = 0
                            if (x[3].strip() == 'extra_op'):
                                self._state.extra_op = 1
                                logging.info((((('Configuration ' + str(self._state.configuration)) + ' Replica ') + str(self._state.r.index(self._state.idr))) + ' put(a,a) performed and applied to running state'))
                                self._state.d['a'] = 'a'
                                self._state.extra_op = 0
                            if (x[3].strip() == 'invalid_order_sig'):
                                self._state.invalid_order_sig = 1
                            if (x[3].strip() == 'invalid_result_sig'):
                                self._state.invalid_result_sig = 1
                            if (x[3].strip() == 'drop_checkpt_stmts'):
                                self._state.drop_checkpt_stmts = 1
            if (self._state.drop == 1):
                logging.info((((('Configuration ' + str(self._state.configuration)) + ' Replica ') + str(self._state.r.index(self._state.idr))) + ' : drop (ignoring) the incoing msg'))
                self._state.drop = 0
                return
            if (not (operation == operation_client)):
                self.send(('reconfig-request',), to=self._state.olympus)
                logging.info((('Configuration ' + str(self._state.configuration)) + ' Replica 0 operation mismatch from client'))
            if (((rid, client) in self._state.rid_slot.keys()) and (self._state.rid_slot[(rid, client)] in self._state.hr.keys())):
                self.send(('re-trans-replica', self._state.hr[self._state.rid_slot[(rid, client)]], self._state.result[self._state.rid_slot[(rid, client)]], rid), to=client)
                logging.info(((((('Configuration ' + str(self._state.configuration)) + ' Replica 0: Replica 0 has the result shuttle cached and sent to Client ') + str(self._state.c.index(client))) + '  rid ') + str(rid)))
            elif (((rid, client) in self._state.rid_slot.keys()) and (self._state.rid_slot[(rid, client)] in self._state.history.keys())):
                logging.info((('Configuration ' + str(self._state.configuration)) + ' Replica 0: Replica 0 has started timer'))
                super()._label('_st_label_4031', block=False)
                _st_label_4031 = 0
                self._timer_start()
                while (_st_label_4031 == 0):
                    _st_label_4031 += 1
                    if (((rid, client) in self._state.rid_slot.keys()) and (self._state.rid_slot[(rid, client)] in self._state.hr.keys())):
                        self.send(('re-trans-replica', self._state.hr[self._state.rid_slot[(rid, client)]], self._state.result[self._state.rid_slot[(rid, client)]]), to=client)
                        logging.info(((((('Configuration ' + str(self._state.configuration)) + ' Replica 0: Replica 0 has the result shuttle cached before timer expired and sent to Client ') + str(self._state.c.index(client))) + '  rid ') + str(rid)))
                        _st_label_4031 += 1
                    elif self._timer_expired:
                        if (self._state.state == 1):
                            logging.info((('Configuration ' + str(self._state.configuration)) + ' Replica 0: Replica 0 timer expired, reconfig request to olympus'))
                            self.output(('olympus id is ' + str(self._state.olympus)))
                            self.send(('reconfig-request',), to=self._state.olympus)
                        _st_label_4031 += 1
                    else:
                        super()._label('_st_label_4031', block=True, timeout=self._state.head_timeout)
                        _st_label_4031 -= 1
            else:
                logging.info(((((('Configuration ' + str(self._state.configuration)) + " Replica 0: Replica 0 doesn't have the slot for Client ") + str(self._state.c.index(client))) + '  rid ') + str(rid)))
                encrypt_oper_rep = self._state.pk.sign(operation.encode())
                encrypt_rid = self._state.pk.sign(str(rid).encode())
                self.send(('head-retrans-head', encrypt_oper_rep, encrypt_oper, encrypt_rid, client), to=self._state.r[0])
                logging.info((((((('Configuration ' + str(self._state.configuration)) + ' Replica 0: Replica 0 has sent request for Client ') + str(self._state.c.index(client))) + '  rid ') + str(rid)) + ' to Replica0 '))
                logging.info((('Configuration ' + str(self._state.configuration)) + ' Replica 0: Replica 0 has started the timer'))
                super()._label('_st_label_4210', block=False)
                _st_label_4210 = 0
                self._timer_start()
                while (_st_label_4210 == 0):
                    _st_label_4210 += 1
                    if (((rid, client) in self._state.rid_slot.keys()) and (self._state.rid_slot[(rid, client)] in self._state.hr.keys())):
                        logging.info(((((('Configuration ' + str(self._state.configuration)) + ' Replica 0: Replica 0 has the result shuttle cached and sent to Client ') + str(self._state.c.index(client))) + '  rid ') + str(rid)))
                        self.send(('re-trans-replica', self._state.hr[self._state.rid_slot[(rid, client)]], self._state.result[self._state.rid_slot[(rid, client)]]), to=client)
                        _st_label_4210 += 1
                    elif self._timer_expired:
                        if (self._state.state == 1):
                            logging.info((('Configuration ' + str(self._state.configuration)) + ' Replica 0: Replica 0 timer expired, reconfig request to olympus'))
                            self.output(('olympus id is ' + str(self._state.olympus)))
                            self.send(('reconfig-request',), to=self._state.olympus)
                        _st_label_4210 += 1
                    else:
                        super()._label('_st_label_4210', block=True, timeout=self._state.head_timeout)
                        _st_label_4210 -= 1
        else:
            pass
    _replica_handler_3320._labels = None
    _replica_handler_3320._notlabels = None

    def _replica_handler_4301(self, encrypt_oper_rep, encrypt_oper, encrypt_rid, client, head):
        if (self._state.state == 1):
            rep_head_dkey = nacl.signing.VerifyKey(self._state.public_key_dict[head], encoder=nacl.encoding.HexEncoder)
            c_head_dkey = nacl.signing.VerifyKey(self._state.public_key_dict[client], encoder=nacl.encoding.HexEncoder)
            try:
                rep_head_dkey.verify(encrypt_oper_rep)
                rep_head_dkey.verify(encrypt_rid)
                c_head_dkey.verify(encrypt_oper)
                operation = encrypt_oper_rep.message.decode()
                operation_client = encrypt_oper.message.decode()
                rid = int(encrypt_rid.message.decode())
            except nacl.exceptions.BadSignatureError:
                logging.error(('Replica 0 : Replica 0 -> Replica 0 forward-req decryption failed for rid ' + str(rid)))
            if (not (operation == operation_client)):
                self.send(('reconfig-request',), to=self._state.olympus)
                logging.info((('Configuration ' + str(self._state.configuration)) + ' Replica 0 operation mismatch from client'))
            self._state.slot = (self._state.slot + 1)
            if (self._state.slot in self._state.history.keys()):
                logging.error(((((('replica 0:  client ' + str(self._state.c.index(client))) + ' -> replica 0 slot error for rid ') + str(rid)) + 'slot ') + str(self._state.slot)))
            self._state.rid_slot[(rid, client)] = self._state.slot
            self._state.orderproof.append([self._state.slot, operation])
            self._state.history[self._state.slot] = [operation, self._state.c.index(client), rid]
            x = split("[,()']+", operation)
            if (x[0] == 'put'):
                self._state.d[x[1]] = x[2]
                self._state.res = 'ok'
            if (x[0] == 'get'):
                try:
                    self._state.res = self._state.d[x[1]]
                except KeyError:
                    self._state.res = ''
            if (x[0] == 'append'):
                try:
                    self._state.d[x[1]] = (self._state.d[x[1]] + x[2])
                    self._state.res = 'update ok'
                except KeyError:
                    self._state.res = 'update failed'
            if (x[0] == 'slice'):
                x[2] = x[2].split(':')
                try:
                    self._state.d[x[1]] = self._state.d[x[1]][int(x[2][0]):int(x[2][1])]
                    self._state.res = 'slice ok'
                except KeyError:
                    self._state.res = 'slice fail'
            self._state.result[self._state.slot] = self._state.res
            i = self._state.r.index(self._state.idr)
            en_res = self._state.res.encode()
            res_digest = nacl.hash.sha256(en_res, encoder=nacl.encoding.HexEncoder)
            res_hash = nacl.encoding.HexEncoder.encode(en_res)
            self._state.hashresult = [[res_digest, res_hash, self._state.slot]]
            self._state.cresult[self._state.c.index(client)] = [res_digest, res_hash, self._state.slot, rid]
            encrypt_operation_rep = self._state.pk.sign(operation.encode())
            encrypt_slot = self._state.pk.sign(str(self._state.slot).encode())
            encrypt_hashresult = self._state.pk.sign(repr(self._state.hashresult).encode())
            encrypt_order_proof = self._state.pk.sign(repr(self._state.orderproof).encode())
            logging.info(((((('Configuration ' + str(self._state.configuration)) + ' Replica 0:  replica 0 -> replica ') + str((i + 1))) + ' for slot ') + str(self._state.slot)))
            self.send(('rep_trans', encrypt_slot, encrypt_operation_rep, encrypt_oper, encrypt_order_proof, encrypt_hashresult, client, self._state.rid_slot, rid), to=self._state.r[(i + 1)])
        else:
            pass
    _replica_handler_4301._labels = None
    _replica_handler_4301._notlabels = None

    def _replica_handler_4749(self, encrypt_operation, encrypt_rid, client):
        logging.info((' overall failure is  ' + str(self._state.failure)))
        if (self._state.state == 1):
            head_client_dkey = nacl.signing.VerifyKey(self._state.public_key_dict[client], encoder=nacl.encoding.HexEncoder)
            try:
                head_client_dkey.verify(encrypt_operation)
                head_client_dkey.verify(encrypt_rid)
                operation = encrypt_operation.message.decode()
                rid = int(encrypt_rid.message.decode())
            except nacl.exceptions.BadSignatureError:
                logging.error(((('replica 0:  client ' + str(self._state.c.index(client))) + ' -head signature fail for rid ') + str(rid)))
            logging.info(((((('Configuration ' + str(self._state.configuration)) + ' Replica 0:  client ') + str(self._state.c.index(client))) + ' -head signature success for rid ') + str(rid)))
            self._state.idr = self._state.r[0]
            i = self._state.r.index(self._state.idr)
            self._state.s = (self._state.s + 1)
            try:
                self._state.ncr[self._state.c.index(client)] = (self._state.ncr[self._state.c.index(client)] + 1)
            except KeyError:
                self._state.ncr[self._state.c.index(client)] = 0
            for x in self._state.fail:
                if (x[0].strip() == 'client_request'):
                    if (int(x[1]) in self._state.ncr.keys()):
                        if ((self._state.ncr[int(x[1])] == int(x[2])) and (int(x[1]) == self._state.c.index(client))):
                            logging.info(((((((((('Configuration ' + str(self._state.configuration)) + ' Replica ') + str(self._state.r.index(self._state.idr))) + ' Client_request failure triggered at replica ') + str(self._state.r.index(self._state.idr))) + '  for client ') + x[1]) + ' message ') + x[2]))
                            if (x[3].strip() == 'change_operation'):
                                self._state.co = 1
                            if (x[3].strip() == 'change_result'):
                                self._state.cr = 1
                            if (x[3].strip() == 'drop_result_stmt'):
                                self._state.drs = 1
                            if (x[3].strip() == 'drop'):
                                self._state.drop = 1
                            if (x[3].strip() == 'truncate_history'):
                                self._state.truncate_history = 1
                                self._state.truncate_history_n = int(x[4])
                            if (x[3].strip() == 'crash'):
                                self._state.crash = 1
                                logging.info((((('Configuration ' + str(self._state.configuration)) + ' Replica ') + str(self._state.r.index(self._state.idr))) + ' : implementing crash failure now..replica exiting..'))
                                self._state.crash = 0
                                logging.shutdown()
                                os._exit((- 1))
                            if (x[3].strip() == 'sleep'):
                                self._state.sleep = 1
                                logging.info((((('Configuration ' + str(self._state.configuration)) + ' Replica ') + str(self._state.r.index(self._state.idr))) + ' sleeping'))
                                time.sleep((int(x[4]) / 1000))
                                logging.info((((('Configuration ' + str(self._state.configuration)) + ' Replica ') + str(self._state.r.index(self._state.idr))) + ' woke up '))
                                self._state.sleep = 0
                            if (x[3].strip() == 'increment_slot'):
                                self._state.increment_slot = 1
                                if (self._state.r.index(self._state.idr) == 0):
                                    self._state.slot = (self._state.slot + 1)
                                logging.info(((((((('Configuration ' + str(self._state.configuration)) + ' Replica ') + str(self._state.r.index(self._state.idr))) + ' slot number incremented from ') + str((self._state.slot - 1))) + ' to ') + str(self._state.slot)))
                                self._state.increment_slot = 0
                            if (x[3].strip() == 'extra_op'):
                                self._state.extra_op = 1
                                logging.info((((('Configuration ' + str(self._state.configuration)) + ' Replica ') + str(self._state.r.index(self._state.idr))) + ' put(a,a) performed and applied to running state'))
                                self._state.d['a'] = 'a'
                                self._state.extra_op = 0
                            if (x[3].strip() == 'invalid_order_sig'):
                                self._state.invalid_order_sig = 1
                            if (x[3].strip() == 'invalid_result_sig'):
                                self._state.invalid_result_sig = 1
                            if (x[3].strip() == 'drop_checkpt_stmts'):
                                self._state.drop_checkpt_stmts = 1
            if (self._state.drop == 1):
                logging.info((((('Configuration ' + str(self._state.configuration)) + ' Replica ') + str(self._state.r.index(self._state.idr))) + ' : drop (ignoring) the incoing msg'))
                self._state.drop = 0
                return
            if (((self._state.slot % self._state.checkpoint) == 0) and (not (self._state.slot == 0))):
                logging.info(((('Configuration ' + str(self._state.configuration)) + ' Replica 0: checkpoint occured for slot ') + str((self._state.slot - 1))))
                self._state.temp_d = self._state.d.copy()
                logging.info(((str(self._state.slot) + ' , ') + str(self._state.temp_d)))
                en_data_dict = repr(self._state.temp_d).encode()
                data_dict_digest = nacl.hash.sha256(en_data_dict, encoder=nacl.encoding.HexEncoder)
                data_dict_hash = nacl.encoding.HexEncoder.encode(en_data_dict)
                self._state.checkpoint_proof = [[data_dict_digest, data_dict_hash, (self._state.slot - 1)]]
                encrypt_checkpoint_proof = self._state.pk.sign(repr(self._state.checkpoint_proof).encode())
                self.send(('forward_chekpoint_proof', encrypt_checkpoint_proof), to=self._state.r[(i + 1)])
                logging.info(((((('Configuration ' + str(self._state.configuration)) + ' Replica 0:  replica 0 -> replica ') + str((i + 1))) + ' checkpoint proof sent for slot ') + str((self._state.slot - 1))))
            self._state.slot = (self._state.slot + 1)
            if (self._state.slot in self._state.history.keys()):
                logging.error(((((('replica 0:  client ' + str(self._state.c.index(client))) + ' -> replica 0 slot error for rid ') + str(rid)) + 'slot ') + str(self._state.slot)))
            if (len(self._state.history) > 0):
                self._state.pslot = max(self._state.history.keys())
            else:
                self._state.pslot = (- 1)
            if (not ((self._state.slot - 1) == self._state.pslot)):
                self.send(('reconfig-request',), to=self._state.olympus)
                logging.error(((((((('replica ' + str((i + 1))) + ':  client ') + str(self._state.c.index(client))) + ' -> replica ') + str((i + 1))) + ' slot error ') + str(self._state.slot)))
            self._state.orderproof = []
            self._state.rid_slot[(rid, client)] = self._state.slot
            self._state.orderproof.append([self._state.slot, operation])
            self._state.history[self._state.slot] = [operation, self._state.c.index(client), rid]
            x = split("[,()']+", operation)
            if (x[0] == 'put'):
                self._state.d[x[1]] = x[2]
                self._state.res = 'ok'
            if (x[0] == 'get'):
                try:
                    self._state.res = self._state.d[x[1]]
                except KeyError:
                    self._state.res = ''
            if (x[0] == 'append'):
                try:
                    self._state.d[x[1]] = (self._state.d[x[1]] + x[2])
                    self._state.res = 'update ok'
                except KeyError:
                    self._state.res = 'update failed'
            if (x[0] == 'slice'):
                x[2] = x[2].split(':')
                try:
                    self._state.d[x[1]] = self._state.d[x[1]][int(x[2][0]):int(x[2][1])]
                    self._state.res = 'slice ok'
                except KeyError:
                    self._state.res = 'slice fail'
            if (self._state.co == 1):
                operation = "get('x')"
                logging.info(((((('Configuration ' + str(self._state.configuration)) + ' Replica ') + str(self._state.r.index(self._state.idr))) + " Operation changed to get('x') at replica ") + str(self._state.r.index(self._state.idr))))
                self._state.co = 0
            if (self._state.cr == 1):
                self._state.res = 'OK'
                logging.info(((((('Configuration ' + str(self._state.configuration)) + ' Replica ') + str(self._state.r.index(self._state.idr))) + " Result changed to 'OK' at replica ") + str(self._state.r.index(self._state.idr))))
                self._state.cr = 0
            self._state.result[self._state.slot] = self._state.res
            en_res = self._state.res.encode()
            res_digest = nacl.hash.sha256(en_res, encoder=nacl.encoding.HexEncoder)
            res_hash = nacl.encoding.HexEncoder.encode(en_res)
            self._state.hashresult = [[res_digest, res_hash, self._state.slot]]
            self._state.cresult[self._state.c.index(client)] = [res_digest, res_hash, self._state.slot, rid]
            if (self._state.drs == 1):
                del self._state.hashresult[0]
                logging.info(((((('Configuration ' + str(self._state.configuration)) + ' Replica ') + str(self._state.r.index(self._state.idr))) + ' :Hashresult of head is omitted at replica ') + str(self._state.r.index(self._state.idr))))
                self._state.drs = 0
            encrypt_operation_rep = self._state.pk.sign(operation.encode())
            encrypt_slot = self._state.pk.sign(str(self._state.slot).encode())
            encrypt_hashresult = self._state.pk.sign(repr(self._state.hashresult).encode())
            encrypt_order_proof = self._state.pk.sign(repr(self._state.orderproof).encode())
            if (self._state.invalid_order_sig == 1):
                self._state.invalid_order_sig = 0
                signedlist = list(encrypt_order_proof)
                signedlist[0] = ((signedlist[0] + 1) % 256)
                newsigned = bytes(signedlist)
                encrypt_order_proof = nacl.signing.SignedMessage._from_parts(encrypt_order_proof._signature, encrypt_order_proof._message, newsigned)
            if (self._state.invalid_result_sig == 1):
                self._state.invalid_result_sig = 0
                signedlist = list(encrypt_hashresult)
                signedlist[0] = ((signedlist[0] + 1) % 256)
                newsigned = bytes(signedlist)
                encrypt_hashresult = nacl.signing.SignedMessage._from_parts(encrypt_hashresult._signature, encrypt_hashresult._message, newsigned)
            if (self._state.drop == 0):
                logging.info(((((('Configuration ' + str(self._state.configuration)) + ' Replica 0:  replica 0 -> replica ') + str((i + 1))) + ' for slot ') + str(self._state.slot)))
                self.send(('rep_trans', encrypt_slot, encrypt_operation_rep, encrypt_operation, encrypt_order_proof, encrypt_hashresult, client, self._state.rid_slot, rid), to=self._state.r[(i + 1)])
            else:
                self._state.drop = 0
                logging.info(((('shuttle dropped by head for client ' + str(self._state.c.index(client))) + ' rid ') + str(rid)))
        else:
            pass
    _replica_handler_4749._labels = None
    _replica_handler_4749._notlabels = None

    def _replica_handler_6052(self, encrypt_hashresult, client, frep):
        if (self._state.state == 1):
            try:
                self._state.nrs[self._state.c.index(client)] = (self._state.nrs[self._state.c.index(client)] + 1)
            except KeyError:
                self._state.nrs[self._state.c.index(client)] = 0
            for x in self._state.fail:
                if (x[0].strip() == 'result_shuttle'):
                    if (int(x[1]) in self._state.nrs.keys()):
                        if ((self._state.nrs[int(x[1])] == int(x[2])) and (int(x[1]) == self._state.c.index(client))):
                            logging.info(((((((((('Configuration ' + str(self._state.configuration)) + ' Replica ') + str(self._state.r.index(self._state.idr))) + ' Result_shuttle failure triggered at replica ') + str(self._state.r.index(self._state.idr))) + '  for client ') + x[1]) + ' message ') + x[2]))
                            if (x[3].strip() == 'change_operation'):
                                self._state.co = 1
                            if (x[3].strip() == 'change_result'):
                                self._state.cr = 1
                            if (x[3].strip() == 'drop_result_stmt'):
                                self._state.drs = 1
                            if (x[3].strip() == 'drop'):
                                self._state.drop = 1
                            if (x[3].strip() == 'truncate_history'):
                                self._state.truncate_history = 1
                                self._state.truncate_history_n = int(x[4])
                            if (x[3].strip() == 'crash'):
                                self._state.crash = 1
                                logging.info((((('Configuration ' + str(self._state.configuration)) + ' Replica ') + str(self._state.r.index(self._state.idr))) + ' : implementing crash failure now..replica exiting..'))
                                self._state.crash = 0
                                logging.shutdown()
                                os._exit((- 1))
                            if (x[3].strip() == 'sleep'):
                                self._state.sleep = 1
                                logging.info((((('Configuration ' + str(self._state.configuration)) + ' Replica ') + str(self._state.r.index(self._state.idr))) + ' sleeping'))
                                time.sleep((int(x[4]) / 1000))
                                logging.info((((('Configuration ' + str(self._state.configuration)) + ' Replica ') + str(self._state.r.index(self._state.idr))) + ' woke up '))
                                self._state.sleep = 0
                            if (x[3].strip() == 'increment_slot'):
                                self._state.increment_slot = 1
                                if (self._state.r.index(self._state.idr) == 0):
                                    self._state.slot = (self._state.slot + 1)
                                logging.info(((((((('Configuration ' + str(self._state.configuration)) + ' Replica ') + str(self._state.r.index(self._state.idr))) + ' slot number incremented from ') + str((self._state.slot - 1))) + ' to ') + str(self._state.slot)))
                                self._state.increment_slot = 0
                            if (x[3].strip() == 'extra_op'):
                                self._state.extra_op = 1
                                logging.info((((('Configuration ' + str(self._state.configuration)) + ' Replica ') + str(self._state.r.index(self._state.idr))) + ' put(a,a) performed and applied to running state'))
                                self._state.d['a'] = 'a'
                                self._state.extra_op = 0
                            if (x[3].strip() == 'invalid_order_sig'):
                                self._state.invalid_order_sig = 1
                            if (x[3].strip() == 'invalid_result_sig'):
                                self._state.invalid_result_sig = 1
                            if (x[3].strip() == 'drop_checkpt_stmts'):
                                self._state.drop_checkpt_stmts = 1
            if (self._state.drop == 1):
                logging.info((((('Configuration ' + str(self._state.configuration)) + ' Replica ') + str(self._state.r.index(self._state.idr))) + ' : drop (ignoring) the incoing msg'))
                self._state.drop = 0
                return
            self._state.s = (self._state.s + 1)
            fr_r_dkey = nacl.signing.VerifyKey(self._state.public_key_dict[frep], encoder=nacl.encoding.HexEncoder)
            try:
                fr_r_dkey.verify(encrypt_hashresult)
                temp_hr = eval(encrypt_hashresult.message.decode())
            except nacl.exceptions.BadSignatureError:
                logging.info((((((((('Configuration ' + str(self._state.configuration)) + ' Replica ') + str(self._state.r.index(self._state.idr))) + ' : Replica ') + str(self._state.r.index(frep))) + ' -> Replica ') + str(self._state.r.index(self._state.idr))) + ' signature fail'))
            logging.info((((((((('Configuration ' + str(self._state.configuration)) + ' Replica ') + str(self._state.r.index(self._state.idr))) + ' : Replica ') + str(self._state.r.index(frep))) + ' -> Replica ') + str(self._state.r.index(self._state.idr))) + ' signature success'))
            for h in temp_hr:
                bres = nacl.encoding.HexEncoder.decode(h[1])
                orig_dgs = nacl.hash.sha256(bres, encoder=nacl.encoding.HexEncoder)
                if sodium_memcmp(h[0], orig_dgs):
                    if (not (bres.decode() == self._state.result[h[2]])):
                        logging.info((((('Configuration ' + str(self._state.configuration)) + ' Replica ') + str(self._state.r.index(self._state.idr))) + ' Proof of misbehaviour : Reshult_shuttle check failed'))
            self._state.hr[h[2]] = temp_hr
            logging.info(((((('Configuration ' + str(self._state.configuration)) + ' Replica ') + str(self._state.r.index(self._state.idr))) + ' Reshult_shuttle cached for slot ') + str(h[2])))
            j = self._state.r.index(frep)
            if ((j - 2) >= 0):
                encrypt_hashresult = self._state.pk.sign(repr(temp_hr).encode())
                self.send(('result-shuttle', encrypt_hashresult, client), to=self._state.r[(j - 2)])
            if ((j - 2) < 0):
                logging.info((((('Configuration ' + str(self._state.configuration)) + ' Replica ') + str(self._state.r.index(self._state.idr))) + ' Reshult_shuttle reached head'))
        else:
            pass
    _replica_handler_6052._labels = None
    _replica_handler_6052._notlabels = None

    def _replica_handler_6785(self, encrypt_checkpoint_proof, prev_rep):
        if (self._state.state == 1):
            self._state.ncm = (self._state.ncm + 1)
            i = self._state.r.index(prev_rep)
            self._state.idr = self._state.r[(i + 1)]
            for x in self._state.fail:
                if (x[0].strip() == 'checkpoint'):
                    if (int(x[1]) == self._state.ncm):
                        logging.info(((((((('Configuration ' + str(self._state.configuration)) + ' Replica ') + str(self._state.r.index(self._state.idr))) + ' : checkpoint failure triggered for ') + str(self._state.ncm)) + ' msg ') + str(x[2])))
                        if (x[2].strip() == 'change_operation'):
                            self._state.co = 1
                        if (x[2].strip() == 'change_result'):
                            self._state.cr = 1
                        if (x[2].strip() == 'drop_result_stmt'):
                            self._state.drs = 1
                        if (x[2].strip() == 'drop'):
                            self._state.drop = 1
                        if (x[2].strip() == 'crash'):
                            self._state.crash = 1
                            logging.info((((('Configuration ' + str(self._state.configuration)) + ' Replica ') + str(self._state.r.index(self._state.idr))) + ' : implementing crash failure now..replica exiting..'))
                            self._state.crash = 0
                            logging.shutdown()
                            os._exit((- 1))
                        if (x[2].strip() == 'truncate_history'):
                            self._state.truncate_history = 1
                            self._state.truncate_history_n = int(x[3])
                        if (x[2].strip() == 'sleep'):
                            self._state.sleep = 1
                            logging.info((((('Configuration ' + str(self._state.configuration)) + ' Replica ') + str(self._state.r.index(self._state.idr))) + ' sleeping'))
                            time.sleep((int(x[3]) / 1000))
                            logging.info((((('Configuration ' + str(self._state.configuration)) + ' Replica ') + str(self._state.r.index(self._state.idr))) + ' woke up '))
                            self._state.sleep = 0
                        if (x[2].strip() == 'increment_slot'):
                            self._state.increment_slot = 1
                            if (self._state.r.index(self._state.idr) == 0):
                                self._state.slot = (self._state.slot + 1)
                            logging.info(((((((('Configuration ' + str(self._state.configuration)) + ' Replica ') + str(self._state.r.index(self._state.idr))) + ' slot number incremented from ') + str((self._state.slot - 1))) + ' to ') + str(self._state.slot)))
                            self._state.increment_slot = 0
                        if (x[2].strip() == 'extra_op'):
                            self._state.extra_op = 1
                            logging.info((((('Configuration ' + str(self._state.configuration)) + ' Replica ') + str(self._state.r.index(self._state.idr))) + ' put(a,a) performed and applied to running state'))
                            self._state.d['a'] = 'a'
                            self._state.extra_op = 0
                        if (x[2].strip() == 'invalid_order_sig'):
                            self._state.invalid_order_sig = 1
                        if (x[2].strip() == 'invalid_result_sig'):
                            self._state.invalid_result_sig = 1
                        if (x[2].strip() == 'drop_checkpt_stmts'):
                            self._state.drop_checkpt_stmts = 1
            if (self._state.drop == 1):
                logging.info((((('Configuration ' + str(self._state.configuration)) + ' Replica ') + str(self._state.r.index(self._state.idr))) + ' : drop (ignoring) the incoing msg'))
                self._state.drop = 0
                return
            fcp_dkey = nacl.signing.VerifyKey(self._state.public_key_dict[prev_rep], encoder=nacl.encoding.HexEncoder)
            try:
                fcp_dkey.verify(encrypt_checkpoint_proof)
            except nacl.exceptions.BadSignatureError:
                logging.error((((((('replica ' + str((i + 1))) + ': replica ') + str(i)) + ' -> replica ') + str((i + 1))) + 'signature fail '))
            logging.info((((((((('Configuration ' + str(self._state.configuration)) + ' Replica ') + str((i + 1))) + ': replica ') + str(i)) + ' -> replica ') + str((i + 1))) + 'signature success '))
            super()._label('_st_label_7285', block=False)
            _st_label_7285 = 0
            while (_st_label_7285 == 0):
                _st_label_7285 += 1
                if (((self._state.slot % self._state.checkpoint) == 0) and (not (self._state.slot == 0))):
                    _st_label_7285 += 1
                else:
                    super()._label('_st_label_7285', block=True)
                    _st_label_7285 -= 1
            checkpoint_proof_list = eval(encrypt_checkpoint_proof.message.decode())
            self._state.temp_d = self._state.d.copy()
            logging.info(((('After fws ckp ' + str(self._state.slot)) + ' , ') + str(self._state.temp_d)))
            en_data_dict = repr(self._state.temp_d).encode()
            data_dict_digest = nacl.hash.sha256(en_data_dict, encoder=nacl.encoding.HexEncoder)
            data_dict_hash = nacl.encoding.HexEncoder.encode(en_data_dict)
            self._state.checkpoint_proof = [data_dict_digest, data_dict_hash, (self._state.slot - 1)]
            logging.info(((((('Configuration ' + str(self._state.configuration)) + ' Replica ') + str(self._state.r.index(self._state.idr))) + ' checkpoint proof added for slot: ') + str(self._state.slot)))
            checkpoint_proof_list.append(self._state.checkpoint_proof)
            encrypt_checkpoint_proof_list = self._state.pk.sign(repr(checkpoint_proof_list).encode())
            if ((i + 2) < len(self._state.r)):
                self.send(('forward_chekpoint_proof', encrypt_checkpoint_proof_list), to=self._state.r[(i + 2)])
                logging.info(((((('Configuration ' + str(self._state.configuration)) + ' Replica ') + str(self._state.r.index(self._state.idr))) + ' checkpoint proof sent to replica: ') + str((i + 2))))
            else:
                for cp in checkpoint_proof_list:
                    bcp = nacl.encoding.HexEncoder.decode(cp[1])
                    orig_dgs = nacl.hash.sha256(bcp, encoder=nacl.encoding.HexEncoder)
                    if sodium_memcmp(cp[0], orig_dgs):
                        if (not (eval(bcp.decode()) == self._state.temp_d)):
                            logging.info((((('Configuration ' + str(self._state.configuration)) + ' Replica ') + str(self._state.r.index(self._state.idr))) + " Proof of misbehaviour : data _dict didn't match"))
                len_wh = len(self._state.wedged_history)
                logging.info(((((((((('Configuration ' + str(self._state.configuration)) + ' Replica ') + str(self._state.r.index(self._state.idr))) + ' history = ') + str(self._state.history)) + ' slot upto to be del ') + str(cp[2])) + ' wedged hist ') + str(self._state.wedged_history)))
                for x in range(len_wh, cp[2]):
                    self._state.wedged_history[x] = self._state.history[x]
                    self._state.history.pop(x)
                logging.info(((((('Configuration ' + str(self._state.configuration)) + ' Replica ') + str(self._state.r.index(self._state.idr))) + ' History Truncated ') + str(self._state.history)))
                self.send(('reverse_chekpoint_proof', encrypt_checkpoint_proof_list), to=prev_rep)
                logging.info(((((('Configuration ' + str(self._state.configuration)) + ' Replica ') + str(self._state.r.index(self._state.idr))) + ' Completed checkpoint proof sent to replica: ') + str(i)))
        else:
            pass
    _replica_handler_6785._labels = None
    _replica_handler_6785._notlabels = None

    def _replica_handler_7628(self, encrypt_checkpoint_proof, frep):
        if (self._state.state == 1):
            self._state.ncom_ch = (self._state.ncom_ch + 1)
            i = (self._state.r.index(self._state.idr) + 1)
            for x in self._state.fail:
                self.output(((str(x) + ' ') + str(self._state.r.index(self._state.idr))))
                if (x[0].strip() == 'completed_checkpoint'):
                    if (int(x[1]) == self._state.ncom_ch):
                        logging.info(((((((('Configuration ' + str(self._state.configuration)) + ' Replica ') + str(self._state.r.index(self._state.idr))) + ' : completed_checkpoint failure triggered for ') + str(self._state.ncom_ch)) + ' msg ') + str(x[2])))
                        if (x[2].strip() == 'change_operation'):
                            self._state.co = 1
                        if (x[2].strip() == 'change_result'):
                            self._state.cr = 1
                        if (x[2].strip() == 'drop_result_stmt'):
                            self._state.drs = 1
                        if (x[2].strip() == 'drop'):
                            self._state.drop = 1
                        if (x[2].strip() == 'crash'):
                            self._state.crash = 1
                            logging.info((((('Configuration ' + str(self._state.configuration)) + ' Replica ') + str(self._state.r.index(self._state.idr))) + ' : implementing crash failure now..replica exiting..'))
                            self._state.crash = 0
                            logging.shutdown()
                            os._exit((- 1))
                        if (x[2].strip() == 'truncate_history'):
                            self._state.truncate_history = 1
                            self._state.truncate_history_n = int(x[3])
                        if (x[2].strip() == 'sleep'):
                            self._state.sleep = 1
                            logging.info((((('Configuration ' + str(self._state.configuration)) + ' Replica ') + str(self._state.r.index(self._state.idr))) + ' sleeping'))
                            time.sleep((int(x[3]) / 1000))
                            logging.info((((('Configuration ' + str(self._state.configuration)) + ' Replica ') + str(self._state.r.index(self._state.idr))) + ' woke up '))
                            self._state.sleep = 0
                        if (x[2].strip() == 'increment_slot'):
                            self._state.increment_slot = 1
                            if (self._state.r.index(self._state.idr) == 0):
                                self._state.slot = (self._state.slot + 1)
                            logging.info(((((((('Configuration ' + str(self._state.configuration)) + ' Replica ') + str(self._state.r.index(self._state.idr))) + ' slot number incremented from ') + str((self._state.slot - 1))) + ' to ') + str(self._state.slot)))
                            self._state.increment_slot = 0
                        if (x[2].strip() == 'extra_op'):
                            self._state.extra_op = 1
                            logging.info((((('Configuration ' + str(self._state.configuration)) + ' Replica ') + str(self._state.r.index(self._state.idr))) + ' put(a,a) performed and applied to running state'))
                            self._state.d['a'] = 'a'
                            self._state.extra_op = 0
                        if (x[2].strip() == 'invalid_order_sig'):
                            self._state.invalid_order_sig = 1
                        if (x[2].strip() == 'invalid_result_sig'):
                            self._state.invalid_result_sig = 1
                        if (x[2].strip() == 'drop_checkpt_stmts'):
                            self._state.drop_checkpt_stmts = 1
            if (self._state.drop == 1):
                logging.info((((('Configuration ' + str(self._state.configuration)) + ' Replica ') + str(self._state.r.index(self._state.idr))) + ' : drop (ignoring) the incoing msg'))
                self._state.drop = 0
                return
            rcp_dkey = nacl.signing.VerifyKey(self._state.public_key_dict[frep], encoder=nacl.encoding.HexEncoder)
            try:
                rcp_dkey.verify(encrypt_checkpoint_proof)
            except nacl.exceptions.BadSignatureError:
                logging.error((((((('replica ' + str((i - 1))) + ': replica ') + str(i)) + ' -> replica ') + str((i - 1))) + 'signature fail '))
            logging.info((((((((('Configuration ' + str(self._state.configuration)) + ' Replica ') + str((i - 1))) + ': replica ') + str(i)) + ' -> replica ') + str((i - 1))) + 'signature success '))
            checkpoint_proof_list = eval(encrypt_checkpoint_proof.message.decode())
            self.output(((('checkpoint_proof_list ' + str(len(checkpoint_proof_list))) + '  r ') + str(len(self._state.r))))
            if (not (len(checkpoint_proof_list) == len(self._state.r))):
                logging.info('Proof of misbehaviour for drop_checkpt_stmts')
                self.send(('reconfig-request',), to=self._state.olympus)
            for cp in checkpoint_proof_list:
                bcp = nacl.encoding.HexEncoder.decode(cp[1])
                orig_dgs = nacl.hash.sha256(bcp, encoder=nacl.encoding.HexEncoder)
                if sodium_memcmp(cp[0], orig_dgs):
                    if (not (eval(bcp.decode()) == self._state.temp_d)):
                        logging.info(((str(eval(bcp.decode())) + ' , ') + str(self._state.temp_d)))
                        logging.info((((('Configuration ' + str(self._state.configuration)) + ' Replica ') + str(self._state.r.index(self._state.idr))) + " Proof of misbehaviour : data _dict didn't match"))
            len_wh = len(self._state.wedged_history)
            logging.info(((((((((('Configuration ' + str(self._state.configuration)) + ' Replica ') + str(self._state.r.index(self._state.idr))) + ' history = ') + str(self._state.history)) + ' slot upto to be del ') + str(cp[2])) + ' wedged hist ') + str(self._state.wedged_history)))
            for x in range(len_wh, cp[2]):
                self._state.wedged_history[x] = self._state.history[x]
                self._state.history.pop(x)
            logging.info(((((('Configuration ' + str(self._state.configuration)) + ' Replica ') + str(self._state.r.index(self._state.idr))) + ' History Truncated ') + str(self._state.history)))
            if (self._state.drop_checkpt_stmts == 1):
                (self._state.drop_checkpt_stmts == 0)
                checkpoint_proof_list = checkpoint_proof_list[int(((len(self._state.r) + 3) / 2)):]
                logging.info((((('Configuration ' + str(self._state.configuration)) + ' Replica ') + str(self._state.r.index(self._state.idr))) + ' Drop checkpoint statements executed'))
            encrypt_checkpoint_proof_list = self._state.pk.sign(repr(checkpoint_proof_list).encode())
            if ((i - 2) >= 0):
                self.send(('reverse_chekpoint_proof', encrypt_checkpoint_proof_list), to=self._state.r[(i - 2)])
                logging.info(((((('Configuration ' + str(self._state.configuration)) + ' Replica ') + str(self._state.r.index(self._state.idr))) + ' Completed Check point proof sent to replica: ') + str((i - 2))))
            else:
                logging.info((((('Configuration ' + str(self._state.configuration)) + ' Replica ') + str(self._state.r.index(self._state.idr))) + ' Completed Check point proof reached head'))
        else:
            pass
    _replica_handler_7628._labels = None
    _replica_handler_7628._notlabels = None

    def _replica_handler_8460(self, encrypt_slot, encrypt_operation_rep, encrypt_operation, encrypt_order_proof, encrypt_hashresult, client, rid_slot, rid, prev_rep):
        if (self._state.state == 1):
            self._state.s = (self._state.s + 1)
            i = self._state.r.index(prev_rep)
            self._state.idr = self._state.r[(i + 1)]
            try:
                self._state.ns[self._state.c.index(client)] = (self._state.ns[self._state.c.index(client)] + 1)
            except KeyError:
                self._state.ns[self._state.c.index(client)] = 0
            for x in self._state.fail:
                if (x[0].strip() == 'shuttle'):
                    if (int(x[1]) in self._state.ns.keys()):
                        if ((self._state.ns[int(x[1])] == int(x[2])) and (int(x[1]) == self._state.c.index(client))):
                            logging.info(((((((((('Configuration ' + str(self._state.configuration)) + ' Replica ') + str(self._state.r.index(self._state.idr))) + ' Shuttle failure triggered at replica ') + str(self._state.r.index(self._state.idr))) + '  for client ') + x[1]) + ' message ') + x[2]))
                            if (x[3].strip() == 'change_operation'):
                                self._state.co = 1
                            if (x[3].strip() == 'change_result'):
                                self._state.cr = 1
                            if (x[3].strip() == 'drop_result_stmt'):
                                self._state.drs = 1
                            if (x[3].strip() == 'drop'):
                                self._state.drop = 1
                            if (x[3].strip() == 'truncate_history'):
                                self._state.truncate_history = 1
                                self._state.truncate_history_n = int(x[4])
                            if (x[3].strip() == 'crash'):
                                self._state.crash = 1
                                logging.info((((('Configuration ' + str(self._state.configuration)) + ' Replica ') + str(self._state.r.index(self._state.idr))) + ' : implementing crash failure now..replica exiting..'))
                                self._state.crash = 0
                                logging.shutdown()
                                os._exit((- 1))
                            if (x[3].strip() == 'sleep'):
                                self._state.sleep = 1
                                logging.info((((('Configuration ' + str(self._state.configuration)) + ' Replica ') + str(self._state.r.index(self._state.idr))) + ' sleeping'))
                                time.sleep((int(x[4]) / 1000))
                                logging.info((((('Configuration ' + str(self._state.configuration)) + ' Replica ') + str(self._state.r.index(self._state.idr))) + ' woke up '))
                                self._state.sleep = 0
                            if (x[3].strip() == 'increment_slot'):
                                self._state.increment_slot = 1
                                if (self._state.r.index(self._state.idr) == 0):
                                    self._state.slot = (self._state.slot + 1)
                                logging.info(((((((('Configuration ' + str(self._state.configuration)) + ' Replica ') + str(self._state.r.index(self._state.idr))) + ' slot number incremented from ') + str((self._state.slot - 1))) + ' to ') + str(self._state.slot)))
                                self._state.increment_slot = 0
                            if (x[3].strip() == 'extra_op'):
                                self._state.extra_op = 1
                                logging.info((((('Configuration ' + str(self._state.configuration)) + ' Replica ') + str(self._state.r.index(self._state.idr))) + ' put(a,a) performed and applied to running state'))
                                self._state.d['a'] = 'a'
                                self._state.extra_op = 0
                            if (x[3].strip() == 'invalid_order_sig'):
                                self._state.invalid_order_sig = 1
                            if (x[3].strip() == 'invalid_result_sig'):
                                self._state.invalid_result_sig = 1
                            if (x[3].strip() == 'drop_checkpt_stmts'):
                                self._state.drop_checkpt_stmts = 1
            if (self._state.drop == 1):
                logging.info((((('Configuration ' + str(self._state.configuration)) + ' Replica ') + str(self._state.r.index(self._state.idr))) + ' : drop (ignoring) the incoing msg'))
                self._state.drop = 0
                return
            pr_r_dkey = nacl.signing.VerifyKey(self._state.public_key_dict[prev_rep], encoder=nacl.encoding.HexEncoder)
            c_r_dkey = nacl.signing.VerifyKey(self._state.public_key_dict[client], encoder=nacl.encoding.HexEncoder)
            try:
                c_r_dkey.verify(encrypt_operation)
                pr_r_dkey.verify(encrypt_operation_rep)
                pr_r_dkey.verify(encrypt_hashresult)
                pr_r_dkey.verify(encrypt_order_proof)
                pr_r_dkey.verify(encrypt_slot)
            except nacl.exceptions.BadSignatureError:
                self.send(('reconfig-request',), to=self._state.olympus)
                logging.error((((((('replica ' + str((i + 1))) + ': replica ') + str(i)) + ' -> replica ') + str((i + 1))) + 'signature fail '))
            logging.info((((((((('Configuration ' + str(self._state.configuration)) + ' Replica ') + str((i + 1))) + ': replica ') + str(i)) + ' -> replica ') + str((i + 1))) + 'signature success '))
            self._state.slot = int(encrypt_slot.message.decode())
            operation = encrypt_operation_rep.message.decode()
            operation_client = encrypt_operation.message.decode()
            if (not (operation == operation_client)):
                self.send(('reconfig-request',), to=self._state.olympus)
                logging.error((((((('replica ' + str((i + 1))) + ': replica ') + str(i)) + ' -> replica ') + str((i + 1))) + 'operation mismatch with client req '))
            logging.info(((((((((('Configuration ' + str(self._state.configuration)) + ' Replica ') + str((i + 1))) + ': shuttle from replica ') + str(i)) + ' -> replica ') + str((i + 1))) + ' is received for slot ') + str(self._state.slot)))
            self._state.hashresult = eval(encrypt_hashresult.message.decode())
            self._state.orderproof = eval(encrypt_order_proof.message.decode())
            if (self._state.slot in self._state.history.keys()):
                self.send(('reconfig-request',), to=self._state.olympus)
                logging.error(((((((('replica ' + str((i + 1))) + ':  client ') + str(self._state.c.index(client))) + ' -> replica ') + str((i + 1))) + ' slot error ') + str(self._state.slot)))
            if (len(self._state.history) > 0):
                self._state.pslot = max(self._state.history.keys())
            else:
                self._state.pslot = (- 1)
            if (not ((self._state.slot - 1) == self._state.pslot)):
                self.send(('reconfig-request',), to=self._state.olympus)
                logging.error(((((((('replica ' + str((i + 1))) + ':  client ') + str(self._state.c.index(client))) + ' -> replica ') + str((i + 1))) + ' slot error ') + str(self._state.slot)))
            else:
                self._state.orderproof.append([self._state.slot, operation])
                self._state.history[self._state.slot] = [operation, self._state.c.index(client), rid]
                self._state.rid_slot = rid_slot
                x = split("[,()']+", operation)
                if (x[0] == 'put'):
                    self._state.d[x[1]] = x[2]
                    self._state.res = 'ok'
                if (x[0] == 'get'):
                    try:
                        self._state.res = self._state.d[x[1]]
                    except KeyError:
                        self._state.res = ''
                if (x[0] == 'append'):
                    try:
                        self._state.d[x[1]] = (self._state.d[x[1]] + x[2])
                        self._state.res = 'update ok'
                    except KeyError:
                        self._state.res = 'update failed'
                if (x[0] == 'slice'):
                    x[2] = x[2].split(':')
                    try:
                        self._state.d[x[1]] = self._state.d[x[1]][int(x[2][0]):int(x[2][1])]
                        self._state.res = 'slice ok'
                    except KeyError:
                        self._state.res = 'slice fail'
                if (self._state.co == 1):
                    operation = "get('x')"
                    logging.info(((((('Configuration ' + str(self._state.configuration)) + ' Replica ') + str(self._state.r.index(self._state.idr))) + " Operation changed to get('x') at replica ") + str(self._state.r.index(self._state.idr))))
                    self._state.co = 0
                if (self._state.cr == 1):
                    self._state.res = 'OK'
                    logging.info(((((('Configuration ' + str(self._state.configuration)) + ' Replica ') + str(self._state.r.index(self._state.idr))) + " Result changed to 'OK' at replica ") + str(self._state.r.index(self._state.idr))))
                    self._state.cr = 0
                self._state.result[self._state.slot] = self._state.res
                en_res = self._state.res.encode()
                res_digest = nacl.hash.sha256(en_res, encoder=nacl.encoding.HexEncoder)
                res_hash = nacl.encoding.HexEncoder.encode(en_res)
                if (self._state.drs == 1):
                    del self._state.hashresult[0]
                    logging.info(((((('Configuration ' + str(self._state.configuration)) + ' Replica ') + str(self._state.r.index(self._state.idr))) + ' :Result shuttle of head is omitted  at replica ') + str(self._state.r.index(self._state.idr))))
                    self._state.drs = 0
                self._state.hashresult.append([res_digest, res_hash, self._state.slot])
                self._state.cresult[self._state.c.index(client)] = [res_digest, res_hash, self._state.slot, rid]
                if ((i + 2) < len(self._state.r)):
                    encrypt_operation_rep = self._state.pk.sign(operation.encode())
                    encrypt_slot = self._state.pk.sign(str(self._state.slot).encode())
                    encrypt_hashresult = self._state.pk.sign(repr(self._state.hashresult).encode())
                    encrypt_order_proof = self._state.pk.sign(repr(self._state.orderproof).encode())
                    if (self._state.invalid_order_sig == 1):
                        self._state.invalid_order_sig = 0
                        signedlist = list(encrypt_order_proof)
                        signedlist[0] = ((signedlist[0] + 1) % 256)
                        newsigned = bytes(signedlist)
                        encrypt_order_proof = nacl.signing.SignedMessage._from_parts(encrypt_order_proof._signature, encrypt_order_proof._message, newsigned)
                    if (self._state.invalid_result_sig == 1):
                        self._state.invalid_result_sig = 0
                        signedlist = list(encrypt_hashresult)
                        signedlist[0] = ((signedlist[0] + 1) % 256)
                        newsigned = bytes(signedlist)
                        encrypt_hashresult = nacl.signing.SignedMessage._from_parts(encrypt_hashresult._signature, encrypt_hashresult._message, newsigned)
                    if (self._state.drop == 0):
                        self.send(('rep_trans', encrypt_slot, encrypt_operation_rep, encrypt_operation, encrypt_order_proof, encrypt_hashresult, client, rid_slot, rid), to=self._state.r[(i + 2)])
                        logging.info(((((((((('Configuration ' + str(self._state.configuration)) + ' Replica ') + str((i + 1))) + ': shuttle from replica ') + str((i + 1))) + ' -> replica ') + str((i + 2))) + ' is sent for slot ') + str(self._state.slot)))
                    else:
                        self._state.drop = 0
                else:
                    self._state.hr[self._state.hashresult[0][2]] = self._state.hashresult
                    encrypt_res = self._state.pk.sign(en_res)
                    encrypt_hashresult = self._state.pk.sign(repr(self._state.hashresult).encode())
                    encrypt_hashresult_shuttle = self._state.pk.sign(repr(self._state.hashresult).encode())
                    self.send(('result-shuttle', encrypt_hashresult_shuttle, client), to=prev_rep)
                    logging.info(((((((('Configuration ' + str(self._state.configuration)) + ' Replica ') + str((i + 1))) + ': result shuttle  from tail  -> replica ') + str((self._state.r.index(self._state.idr) - 1))) + ' is sent for slot ') + str(self._state.slot)))
                    if (self._state.invalid_result_sig == 1):
                        self._state.invalid_result_sig = 0
                        signedlist = list(encrypt_hashresult)
                        signedlist[0] = ((signedlist[0] + 1) % 256)
                        newsigned = bytes(signedlist)
                        encrypt_hashresult = nacl.signing.SignedMessage._from_parts(encrypt_hashresult._signature, encrypt_hashresult._message, newsigned)
                    if (self._state.drop == 0):
                        self.send(('result', encrypt_hashresult, encrypt_res, rid), to=client)
                        logging.info(((((((('Configuration ' + str(self._state.configuration)) + ' Replica ') + str((i + 1))) + ': result from tail  -> client ') + str(self._state.c.index(client))) + ' is sent for slot ') + str(self._state.slot)))
                    else:
                        self._state.drop = 0
        else:
            pass
    _replica_handler_8460._labels = None
    _replica_handler_8460._notlabels = None

    def _replica_handler_9958(self, olympus):
        logging.info((((('Configuration ' + str(self._state.configuration)) + ' Replica ') + str(self._state.r.index(self._state.idr))) + ': killed'))
        self._state.kill = True
    _replica_handler_9958._labels = None
    _replica_handler_9958._notlabels = None

    def _replica_handler_9991(self, olympus):
        logging.info((((('Configuration ' + str(self._state.configuration)) + ' Replica ') + str(self._state.r.index(self._state.idr))) + ': new config from olympus'))
        for x in self._state.fail:
            if (x[0].strip() == 'new_configuration'):
                if (int(x[1]) == (self._state.configuration - 1)):
                    logging.info((((('Configuration ' + str(self._state.configuration)) + ' Replica ') + str(self._state.r.index(self._state.idr))) + ' : new_configuration failure triggered '))
                    if (x[2].strip() == 'change_operation'):
                        self._state.co = 1
                    if (x[2].strip() == 'change_result'):
                        self._state.cr = 1
                    if (x[2].strip() == 'drop_result_stmt'):
                        self._state.drs = 1
                    if (x[2].strip() == 'drop'):
                        self._state.drop = 1
                    if (x[2].strip() == 'truncate_history'):
                        self._state.truncate_history = 1
                        self._state.truncate_history_n = int(x[3])
                    if (x[2].strip() == 'crash'):
                        self._state.crash = 1
                        logging.info((((('Configuration ' + str(self._state.configuration)) + ' Replica ') + str(self._state.r.index(self._state.idr))) + ' : implementing crash failure now..replica exiting..'))
                        self._state.crash = 0
                        logging.shutdown()
                        os._exit((- 1))
                    if (x[2].strip() == 'sleep'):
                        self._state.sleep = 1
                        logging.info((((('Configuration ' + str(self._state.configuration)) + ' Replica ') + str(self._state.r.index(self._state.idr))) + ' sleeping'))
                        time.sleep((int(x[3]) / 1000))
                        logging.info((((('Configuration ' + str(self._state.configuration)) + ' Replica ') + str(self._state.r.index(self._state.idr))) + ' woke up '))
                        self._state.sleep = 0
                    if (x[2].strip() == 'increment_slot'):
                        self._state.increment_slot = 1
                        if (self._state.r.index(self._state.idr) == 0):
                            self._state.slot = (self._state.slot + 1)
                        logging.info(((((((('Configuration ' + str(self._state.configuration)) + ' Replica ') + str(self._state.r.index(self._state.idr))) + ' slot number incremented from ') + str((self._state.slot - 1))) + ' to ') + str(self._state.slot)))
                        self._state.increment_slot = 0
                    if (x[2].strip() == 'extra_op'):
                        self._state.extra_op = 1
                        logging.info((((('Configuration ' + str(self._state.configuration)) + ' Replica ') + str(self._state.r.index(self._state.idr))) + ' put(a,a) performed and applied to running state'))
                        self._state.d['a'] = 'a'
                        self._state.extra_op = 0
                    if (x[2].strip() == 'invalid_order_sig'):
                        self._state.invalid_order_sig = 1
                    if (x[2].strip() == 'invalid_result_sig'):
                        self._state.invalid_result_sig = 1
                    if (x[2].strip() == 'drop_checkpt_stmts'):
                        self._state.drop_checkpt_stmts = 1
        if (self._state.drop == 1):
            logging.info((((('Configuration ' + str(self._state.configuration)) + ' Replica ') + str(self._state.r.index(self._state.idr))) + ' : drop (ignoring) the incoing msg'))
            self._state.drop = 0
            return
        logging.info((('Configuration ' + str(self._state.configuration)) + ' Replica change state to active'))
        self._state.state = 1
    _replica_handler_9991._labels = None
    _replica_handler_9991._notlabels = None
