# -*- generated by 1.0.11 -*-
import da
PatternExpr_501 = da.pat.TuplePattern([da.pat.ConstantPattern('wedged_statement1'), da.pat.FreePattern('h')])
PatternExpr_508 = da.pat.FreePattern('rep')
PatternExpr_544 = da.pat.TuplePattern([da.pat.ConstantPattern('wedged_statement'), da.pat.FreePattern('h')])
PatternExpr_551 = da.pat.FreePattern('rep')
PatternExpr_825 = da.pat.TuplePattern([da.pat.ConstantPattern('caught_up_res'), da.pat.FreePattern('data_dict_digest'), da.pat.FreePattern('data_dict_hash'), da.pat.FreePattern('cresult')])
PatternExpr_836 = da.pat.FreePattern('rep')
PatternExpr_1209 = da.pat.TuplePattern([da.pat.ConstantPattern('get_running_state_res'), da.pat.FreePattern('data_dict_digest'), da.pat.FreePattern('data_dict_hash'), da.pat.FreePattern('cresult')])
PatternExpr_1220 = da.pat.FreePattern('rep')
PatternExpr_1596 = da.pat.TuplePattern([da.pat.ConstantPattern('client-reconfig-request')])
PatternExpr_1601 = da.pat.FreePattern('cl')
PatternExpr_1631 = da.pat.TuplePattern([da.pat.ConstantPattern('reconfig-request')])
PatternExpr_1636 = da.pat.FreePattern('rep')
_config_object = {}
import sys
import nacl.encoding
import nacl.hash
import nacl.signing
import itertools
from nacl.bindings.utils import sodium_memcmp
from re import split
import time
import logging
Replica = da.import_da('Replica')

class Olympus(da.DistProcess):

    def __init__(self, procimpl, props):
        super().__init__(procimpl, props)
        self._events.extend([da.pat.EventPattern(da.pat.ReceivedEvent, '_OlympusReceivedEvent_0', PatternExpr_501, sources=[PatternExpr_508], destinations=None, timestamps=None, record_history=None, handlers=[self._Olympus_handler_500]), da.pat.EventPattern(da.pat.ReceivedEvent, '_OlympusReceivedEvent_1', PatternExpr_544, sources=[PatternExpr_551], destinations=None, timestamps=None, record_history=None, handlers=[self._Olympus_handler_543]), da.pat.EventPattern(da.pat.ReceivedEvent, '_OlympusReceivedEvent_2', PatternExpr_825, sources=[PatternExpr_836], destinations=None, timestamps=None, record_history=None, handlers=[self._Olympus_handler_824]), da.pat.EventPattern(da.pat.ReceivedEvent, '_OlympusReceivedEvent_3', PatternExpr_1209, sources=[PatternExpr_1220], destinations=None, timestamps=None, record_history=None, handlers=[self._Olympus_handler_1208]), da.pat.EventPattern(da.pat.ReceivedEvent, '_OlympusReceivedEvent_4', PatternExpr_1596, sources=[PatternExpr_1601], destinations=None, timestamps=None, record_history=None, handlers=[self._Olympus_handler_1595]), da.pat.EventPattern(da.pat.ReceivedEvent, '_OlympusReceivedEvent_5', PatternExpr_1631, sources=[PatternExpr_1636], destinations=None, timestamps=None, record_history=None, handlers=[self._Olympus_handler_1630])])

    def setup(self, config, c, r, parent, olympus, num_replica, **rest_1979):
        super().setup(config=config, c=c, r=r, parent=parent, olympus=olympus, num_replica=num_replica, **rest_1979)
        self._state.config = config
        self._state.c = c
        self._state.r = r
        self._state.parent = parent
        self._state.olympus = olympus
        self._state.num_replica = num_replica
        self._state.config = self._state.config
        self._state.failure = dict()
        self._state.count = 0
        self._state.history = dict()
        self._state.count1 = 0
        self._state.data_dict = dict()
        self._state.catchup = dict()
        self._state.lh = dict()
        self._state.lhr = 0
        self._state.flag = False
        self._state.client_rs = dict()
        self._state.public_key_dict = dict()
        self._state.private_key_dict = dict()
        self._state.a = False
        self._state.head_timeout = 0
        self._state.nonhead_timeout = 0
        self._state.client_timeout = 0
        self._state.configuration = 0
        self._state.match_t1 = True
        self._state.grs = 2
        self._state.combr = []
        self._state.comb_t1 = []
        self._state.checkpoint = 0
        self._state.client_rs = dict()

    def run(self):
        logging.basicConfig(format='%(asctime)s : %(message)s', level=logging.INFO, filename=(sys.argv[(- 1)][0:(- 4)] + '_log.log'))
        self._state.checkpoint = int(self._state.config['checkpt_interval'])
        self._state.head_timeout = (self._state.config['head_timeout'] / 1000)
        self._state.nonhead_timeout = (self._state.config['nonhead_timeout'] / 1000)
        self._state.client_timeout = (self._state.config['client_timeout'] / 1000)
        for x in self._state.config.keys():
            if x.startswith('failures'):
                if (int(x[(- 4)]) == self._state.configuration):
                    self._state.failure[x[(- 2)]] = self._state.config[x].split(';')
        self.output(self._state.failure)
        s = (- 1)
        d = dict()
        hist = dict()
        self._state.a = False
        self._state.public_key_dict = dict()
        self._state.private_key_dict = dict()
        signing_key = nacl.signing.SigningKey.generate()
        self._state.public_key_dict[self._state.parent[0]] = signing_key.verify_key.encode(encoder=nacl.encoding.HexEncoder)
        self._state.private_key_dict[self._state.parent[0]] = signing_key
        for x in self._state.c:
            signing_key = nacl.signing.SigningKey.generate()
            self._state.public_key_dict[x] = signing_key.verify_key.encode(encoder=nacl.encoding.HexEncoder)
            self._state.private_key_dict[x] = signing_key
        logging.info((('Configuration ' + str(self._state.configuration)) + ' Olympus : Generated Signature keys for clients'))
        for x in self._state.r:
            signing_key = nacl.signing.SigningKey.generate()
            self._state.public_key_dict[x] = signing_key.verify_key.encode(encoder=nacl.encoding.HexEncoder)
            self._state.private_key_dict[x] = signing_key
        logging.info((('Configuration ' + str(self._state.configuration)) + ' Olympus : Generated Signature keys for replicas'))
        self.output(self._state.olympus[0])
        for x in self._state.r:
            self._setup(x, (self._state.a, d, hist, s, self._state.r, x, self._state.c, self._state.public_key_dict, self._state.private_key_dict[x], self._state.nonhead_timeout, self._state.head_timeout, self._state.failure, self._state.olympus[0], self._state.configuration, self._state.checkpoint))
        self._start(self._state.r)
        self.send(('active',), to=self._state.r)
        for (i, x) in enumerate(self._state.c):
            self._setup(x, (self._state.config[(('workload[' + str(i)) + ']')], self._state.r, self._state.c, x, self._state.public_key_dict, self._state.private_key_dict[x], self._state.client_timeout, self._state.parent[0], self._state.olympus[0]))
        self._setup(self._state.parent, (self._state.c, self._state.public_key_dict, self._state.private_key_dict[self._state.parent[0]]))
        self._start(self._state.c)
        self._start(self._state.parent)
        super()._label('_st_label_1977', block=False)
        _st_label_1977 = 0
        while (_st_label_1977 == 0):
            _st_label_1977 += 1
            if False:
                _st_label_1977 += 1
            else:
                super()._label('_st_label_1977', block=True)
                _st_label_1977 -= 1

    def check_consistency(self, comb, history, r):
        rep_pair = itertools.combinations(comb, 2)
        for x in rep_pair:
            for h in history[r.index(x[0])]:
                if (h in history[r.index(x[1])].keys()):
                    if (not (history[r.index(x[1])][h] == history[r.index(x[0])][h])):
                        return False
        return True

    def longest_history(self, comb, history, r):
        max_len = 0
        l = 0
        self._state.lh = dict()
        self._state.lhr = r.index(comb[0])
        for x in comb:
            l = len(history[r.index(x)])
            if (l > max_len):
                max_len = l
                self._state.lhr = r.index(x)
                self._state.lh = history[r.index(x)]
        return self._state.lh

    def update_history(self):
        self.send(('wedged_req1',), to=self._state.r)

    def newconfig(self, data_dict, client_rs):
        self._state.configuration = (self._state.configuration + 1)
        self._state.failure = dict()
        for x in self._state.config.keys():
            if x.startswith('failures'):
                if (int(x[(- 4)]) == self._state.configuration):
                    self._state.failure[x[(- 2)]] = self._state.config[x].split(';')
        new_r = list(self.new(Replica.replica, num=self._state.num_replica))
        old_r = self._state.r
        logging.info((('Configuration ' + str(self._state.configuration)) + ' Olympus : new replicas created'))
        s = (- 1)
        h = dict()
        self._state.count = 0
        self._state.count1 = 0
        self._state.grs = 2
        self._state.combr = []
        for x in new_r:
            signing_key = nacl.signing.SigningKey.generate()
            self._state.public_key_dict[x] = signing_key.verify_key.encode(encoder=nacl.encoding.HexEncoder)
            self._state.private_key_dict[x] = signing_key
        logging.info((('Configuration ' + str(self._state.configuration)) + ' Olympus : Generated Signature keys for new replicas'))
        for x in new_r:
            self._setup(x, (self._state.a, data_dict, h, s, new_r, x, self._state.c, self._state.public_key_dict, self._state.private_key_dict[x], self._state.nonhead_timeout, self._state.head_timeout, self._state.failure, self._state.olympus[0], self._state.configuration, self._state.checkpoint))
        self._start(new_r)
        self.send(('active',), to=new_r)
        logging.info(((('Configuration ' + str(self._state.configuration)) + ' Olympus : Setup  and started new replicas + client_rs') + str(client_rs)))
        if (len(client_rs) == 0):
            for y in self._state.c:
                self.send(('new-config', new_r, [], self._state.public_key_dict), to=y)
        else:
            for y in client_rs:
                self.send(('new-config', new_r, client_rs[y], self._state.public_key_dict), to=self._state.c[y])
                logging.info((('Configuration ' + str(self._state.configuration)) + ' Olympus :  new replicas info sent to client'))
        self.send(('kill',), to=self._state.r)
        self._state.r = new_r
        self._state.data_dict.clear()
        self._state.client_rs.clear()

    def _Olympus_handler_500(self, h, rep):
        self._state.history[self._state.r.index(rep)] = h
        self._state.combr.append(rep)
        logging.info(((('replica  ' + str(self._state.r.index(rep))) + ' with history ') + str(h)))
    _Olympus_handler_500._labels = None
    _Olympus_handler_500._notlabels = None

    def _Olympus_handler_543(self, h, rep):
        logging.info(((((('Configuration ' + str(self._state.configuration)) + ' Olympus received wedged statement from replica  ') + str(self._state.r.index(rep))) + ' with history ') + str(h)))
        self._state.count = (self._state.count + 1)
        enter = (int(((len(self._state.r) - 1) / 2)) + 1)
        self._state.history[self._state.r.index(rep)] = h
        self._state.combr.append(rep)
        if (self._state.count > int(((len(self._state.r) - 1) / 2))):
            enter = 0
            self._state.count = 0
            logging.info(((('Configuration ' + str(self._state.configuration)) + ' Olympus :enter history is ') + str(self._state.history)))
            len_t1 = (int(((len(self._state.r) - 1) / 2)) + 1)
            super()._label('_st_label_654', block=False)
            _st_label_654 = 0
            self._timer_start()
            while (_st_label_654 == 0):
                _st_label_654 += 1
                if (self._state.count == len(self._state.r)):
                    self._state.comb_t1 = list(itertools.combinations(self._state.combr, len_t1))
                    _st_label_654 += 1
                elif self._timer_expired:
                    self._state.comb_t1 = list(itertools.combinations(self._state.combr, len_t1))
                    _st_label_654 += 1
                else:
                    super()._label('_st_label_654', block=True, timeout=1)
                    _st_label_654 -= 1
            for comb in self._state.comb_t1:
                self.output('new comb taken')
                self.update_history()
                self._state.flag = False
                self._state.match_t1 = True
                if self.check_consistency(comb, self._state.history, self._state.r):
                    self.output('check_consistency passed')
                    self._state.lh = self.longest_history(comb, self._state.history, self._state.r)
                    logging.info((('Configuration ' + str(self._state.configuration)) + ' Olympus :lh calculated '))
                    logging.info(((((('Configuration ' + str(self._state.configuration)) + 'longest history of comb ') + str(comb)) + ' is ') + str(self._state.lh)))
                    for replica in comb:
                        self._state.catchup = dict()
                        for x in self._state.lh:
                            if (not (x in self._state.history[self._state.r.index(replica)].keys())):
                                self._state.catchup[x] = self._state.lh[x]
                        logging.info(((('catchup of replica ' + str(self._state.r.index(replica))) + 'is ') + str(self._state.catchup)))
                        self.send(('catch_up_req', self._state.catchup), to=replica)
                        logging.info(((('Configuration ' + str(self._state.configuration)) + ' Olympus sent catch up msg  ') + str(self._state.r.index(replica))))
                else:
                    self._state.flag = True
                super()._label('_st_label_820', block=False)
                _st_label_820 = 0
                while (_st_label_820 == 0):
                    _st_label_820 += 1
                    if self._state.flag:
                        _st_label_820 += 1
                    else:
                        super()._label('_st_label_820', block=True)
                        _st_label_820 -= 1
                else:
                    if (_st_label_820 != 2):
                        continue
                if (_st_label_820 != 2):
                    break
    _Olympus_handler_543._labels = None
    _Olympus_handler_543._notlabels = None

    def _Olympus_handler_824(self, data_dict_digest, data_dict_hash, cresult, rep):
        logging.info(((('Configuration ' + str(self._state.configuration)) + ' Olympus received caught_up_res from replica  ') + str(self._state.r.index(rep))))
        self._state.count1 = (self._state.count1 + 1)
        b_data_dict_hash = nacl.encoding.HexEncoder.decode(data_dict_hash)
        orig_dgs = nacl.hash.sha256(b_data_dict_hash, encoder=nacl.encoding.HexEncoder)
        if sodium_memcmp(data_dict_digest, orig_dgs):
            self._state.data_dict[self._state.r.index(rep)] = eval(b_data_dict_hash.decode())
        for y in cresult:
            try:
                self._state.client_rs[y].append(cresult[y])
            except KeyError:
                self._state.client_rs[y] = [cresult[y]]
        logging.info(((((('Configuration ' + str(self._state.configuration)) + ' Olympus ckient_rs is ') + str(self._state.client_rs)) + ' from replica ') + str(self._state.r.index(rep))))
        self.output(((('count ' + str(self._state.count1)) + ' length ') + str((int(((len(self._state.r) - 1) / 2)) + 1))))
        super()._label('_st_label_970', block=False)
        _st_label_970 = 0
        self._timer_start()
        while (_st_label_970 == 0):
            _st_label_970 += 1
            if (self._state.count1 == (int(((len(self._state.r) - 1) / 2)) + 1)):
                self._state.flag = False
                self.output(('The data dicts received are: ' + str(self._state.data_dict)))
                keys = []
                for k in self._state.data_dict:
                    keys.append(k)
                logging.info(((('Configuration ' + str(self._state.configuration)) + ' Olympus dict keys are ') + str(keys)))
                match_count = 0
                for (i, k) in enumerate(keys):
                    if (i == (len(keys) - 1)):
                        break
                    logging.info(((((('Configuration ' + str(self._state.configuration)) + ' Olympus ') + str(self._state.data_dict[keys[i]])) + ';') + str(self._state.data_dict[keys[i]])))
                    if (not (self._state.data_dict[keys[i]] == self._state.data_dict[keys[(i + 1)]])):
                        self.output('control here : not matching')
                        self._state.flag = True
                        match_count = 0
                        self._state.count1 = 0
                        self._state.count = 0
                        self._state.data_dict = dict()
                        self._state.client_rs = dict()
                        break
                    else:
                        match_count = (match_count + 1)
                if (match_count == (len(keys) - 1)):
                    logging.info((('Configuration ' + str(self._state.configuration)) + ' Olympus caught_up_res matched for quorum'))
                    for (i, k) in enumerate(keys):
                        self.send(('get_running_state',), to=self._state.r[k])
                        super()._label('_st_label_1148', block=False)
                        _st_label_1148 = 0
                        while (_st_label_1148 == 0):
                            _st_label_1148 += 1
                            if (not (self._state.grs == 2)):
                                _st_label_1148 += 1
                            else:
                                super()._label('_st_label_1148', block=True)
                                _st_label_1148 -= 1
                        else:
                            if (_st_label_1148 != 2):
                                continue
                        if (_st_label_1148 != 2):
                            break
                        if (self._state.grs == 1):
                            self.output('control here1')
                            break
                        else:
                            self.output('control here2')
                            self._state.grs = 2
                    self.newconfig(list(self._state.data_dict.values())[0], self._state.client_rs)
                _st_label_970 += 1
            elif self._timer_expired:
                if (self._state.count1 > 1):
                    self.output(len(list(self._state.comb_t1)))
                    match_count = 0
                    self._state.count1 = 0
                    self._state.count = 0
                    self._state.data_dict = dict()
                    self._state.client_rs = dict()
                    self._state.flag = True
                _st_label_970 += 1
            else:
                super()._label('_st_label_970', block=True, timeout=0.01)
                _st_label_970 -= 1
    _Olympus_handler_824._labels = None
    _Olympus_handler_824._notlabels = None

    def _Olympus_handler_1208(self, data_dict_digest, data_dict_hash, cresult, rep):
        logging.info(((str(rep) + '   ') + str(self._state.r)))
        logging.info(((((('Configuration ' + str(self._state.configuration)) + ' Olympus received get_running_state_res from replica  ') + str(self._state.r.index(rep))) + 'lh rep is ') + str(self._state.lhr)))
        b_data_dict_hash = nacl.encoding.HexEncoder.decode(data_dict_hash)
        orig_dgs = nacl.hash.sha256(b_data_dict_hash, encoder=nacl.encoding.HexEncoder)
        if sodium_memcmp(data_dict_digest, orig_dgs):
            if (self._state.data_dict[self._state.lhr] == eval(b_data_dict_hash.decode())):
                logging.info((((('Configuration ' + str(self._state.configuration)) + ' Olympus received get_running_state_res from replica  ') + str(self._state.r.index(rep))) + ' and they macthed'))
                self.output('about to change grs to 1')
                self._state.grs = 1
                self.output(self._state.grs)
            else:
                logging.info((((('Configuration ' + str(self._state.configuration)) + ' Olympus received get_running_state_res from replica  ') + str(self._state.r.index(rep))) + ' and they failed to macth'))
                self._state.grs = 0
    _Olympus_handler_1208._labels = None
    _Olympus_handler_1208._notlabels = None

    def _Olympus_handler_1595(self, cl):
        logging.info((((('Configuration ' + str(self._state.configuration)) + ' Olympus received reconfig req from client') + str(self._state.c.index(cl))) + ' and sent the wedged request to replicas '))
        self.send(('wedged_req',), to=self._state.r)
    _Olympus_handler_1595._labels = None
    _Olympus_handler_1595._notlabels = None

    def _Olympus_handler_1630(self, rep):
        self.send(('wedge_client',), to=self._state.c)
        logging.info((((('Configuration ' + str(self._state.configuration)) + ' Olympus received reconfig req from replica') + str(self._state.r.index(rep))) + ' and sent the wedged request to replicas '))
        self.send(('wedged_req',), to=self._state.r)
    _Olympus_handler_1630._labels = None
    _Olympus_handler_1630._notlabels = None
